<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kernel Development</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Kernel Development</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#what-is-memory">What is memory?</a></li>
<li><a href="#the-boot-process">The Boot Process</a></li>
<li><a href="#getting-setup-for-kernel-development">Getting setup for Kernel development</a></li>
<li><a href="#assembly-language">Assembly language</a></li>
<li><a href="#real-mode">Real Mode</a><ul>
<li><a href="#working-with-the-segmentation-memory-model">Working with the Segmentation Memory Model</a></li>
<li><a href="#interrupts-and-the-interrupt-vector-table">Interrupts and the Interrupt Vector Table</a></li>
<li><a href="#reading-from-disk">Reading from disk</a></li>
</ul></li>
<li><a href="#protected-mode">Protected Mode</a><ul>
<li><a href="#switching-to-protected-mode">Switching to Protected Mode</a></li>
</ul></li>
<li><a href="#building-a-c-compiler">Building a C Compiler</a></li>
<li><a href="#bits-byte-binary-and-hex">Bits, byte, binary and hex</a></li>
</ul>
</nav>
<p>This is based on a <a href="https://dragonzap.com/course/developing-a-multithreaded-kernel-from-scratch?coupon=YOUTUBEKERNEL2022">course</a> which guides the reader through the development of a full OS kernel, from a Hello World Bootloader to a multitasking kernel with a FAT16 file system. The first 11 lessons are available for free on <a href="https://www.youtube.com/watch?v=HNIg3TXfdX8&amp;list=PLrGN1Qi7t67V-9uXzj4VSQCffntfvn42v">YouTube</a></p>
<h2 id="what-is-memory">What is memory?</h2>
<div class="tufte-section">
<div class="main-text">
<p>Memory is a piece of hardware that allows computers to store information. Programs can read and write to <em>Random Access Memory</em> (RAM). It’s only used for temporary storage, such as for variable storage of the programs you write. RAM is wiped when you shut down the computer. <em>Read Only Memory</em> (ROM) does <em>not</em> vanish when you shut down the computer. But as the name suggests, you can’t write to it. In a home PC, the BIOS program is stored in ROM.</p>
<p>Memory is generally accessed in a linear fashion. The data is stored in order. The way your processor accesses memory abstracts this.</p>
</div>
<div class="sidenotes">

</div>
</div>
<h2 id="the-boot-process">The Boot Process</h2>
<div class="tufte-section">
<div class="main-text">
<p>The boot process has three steps:</p>
<ol type="1">
<li>The BIOS<sup>1</sup> program is executed from ROM/BIOS Chip</li>
<li>The BIOS loads the <em>Bootloader</em> into memory address <code>0x7C00</code></li>
<li>The Bootloader loads the Kernel</li>
</ol>
<p>When the computer is switched on, the CPU will read from the BIOS ROM and start executing instructions it finds there. The BIOS usually loads itself into RAM for performance reasons and will continue to execute from there. The BIOS also identifies and initializes the computer’s hardware, such as disk drivers.</p>
<p>The final thing the BIOS does is try to find a Bootloader. It searches all available storage mediums - USB drives, hard disks - for the magic boot signature <code>0x55AA</code>. It will look in the last bytes of the first sector<sup>2</sup>, and if the signature is found, it will load that sector into address <code>0x7C00</code>, and the CPU will start to execute from that address.</p>
<p>When a computer first boots, it does so in <em>“Real Mode”</em>. This is a very limited ‘compatibility’ mode, with access to only 1Mb of memory, and it can only execute 16 bit code. The Bootloader is a small program whose job is to put the computer into <em>“Protected Mode”</em>, which allows 32 bit code and access to 4Gb of memory, and then to load the kernel of an operating system.</p>
<p>The BIOS contains routines that the bootloader uses to boot the kernel. The interfaces of BIOS routines are generic and standardized across manufacturers.</p>
</div>
<div class="sidenotes">
<p><sup>1</sup> Basic Input Output System</p>
<figure>
<img src="../../images/2021_03_21_kerneldev/booting.png" alt="booting" /><figcaption>booting</figcaption>
</figure>
<p><sup>2</sup> A sector is a block of storage. For example, a hard disk is made up of 512 byte sectors. The BIOS will look in the byte addresses 511 and 512 of the sector.</p>
</div>
</div>
<h2 id="getting-setup-for-kernel-development">Getting setup for Kernel development</h2>
<div class="tufte-section">
<div class="main-text">
<p>All development will be done on Ubuntu Linux. First, make sure your repositories are up to date. Then, install nasm<sup>1</sup>. Finally, we will use the QEmu emulator to run our bootloader and kernel. Test that it runs using the below commands. A new window will pop up, but since there are no disks attached it won’t be able to boot.</p>
<pre><code>sudo apt update
sudo apt install nasm

sudo apt install qemu-system-x86
qemu-system-x86_64</code></pre>
</div>
<div class="sidenotes">
<p><sup>1</sup> NASM is the “Netwide Assembler”, and assembler for the x86 CPU architecture, compatible with nearly every modern platform. https://nasm.us</p>
</div>
</div>
<h2 id="assembly-language">Assembly language</h2>
<div class="tufte-section">
<div class="main-text">
<p>This is a short refresher on what assembly language is. Or, for me, basically an introduction to it, since I’ve never written it before.</p>
<p>Your processor has an <em>instruction set</em>, or machine codes. Assembly language gets passed through an <em>assembler</em>, and machine codes your processor understands come out the other side. Use <a href="https://emu8086-microprocessor-emulator.en.softonic.com/">Emu8086</a> to easily test assembly programs.<sup>2</sup></p>
<p>Write the following program in your emulator:</p>
<pre class="assembly"><code>mov ah, 0eh
mov al, &#39;A&#39;
int 10h</code></pre>
<p>This is a program that outputs ‘A’ to the screen. <code>mov X Y</code> moves data Y to register<sup>3</sup> X. <code>ah</code> (“Accumulator High”) and <code>al</code> (“Accumulator Low”) are registers storing one byte. So here we move <code>0eh</code><sup>4</sup> into <code>ah</code>, and the character ‘A’ (65) into <code>al</code>. <code>int X</code> means <em>“interrupt with code X”</em>. The code <code>10h</code> outputs things to the screen<sup>5</sup>.</p>
<p>So we have a program that outputs a <em>character</em> to a screen. Now we need to output multiple characters. Here is our next program.</p>
<pre class="assembly"><code>jmp main

message: db &#39;Hello World!&#39;, 0

print:
    mov ah, 0eh
._loop:
    lodsb
    cmp al, 0
    je .done
    int 10h
    jmp ._loop
.done:
    ret

main:
    mov si, message
    call print</code></pre>
<p>The first thing to point out is that assembly always executes top-to-bottom unless you specifically tell it to jump to somewhere else. This is done with <em>labels</em>. These are the words that end with colons, like <code>main:</code>. For example <code>print</code> is a subroutine, and when it is called with <code>call print</code>, the program will start executing at this point.</p>
<p>The line <code>message: db 'Hello World!', 0</code>, puts a block of data representing the bytes ‘Hello World!’ at the starting memory location (<code>db</code> mean data bytes I think). The zero at the end is the ‘null’ terminator. We have to put <code>jmp main</code> above that, otherwise the processor will try to execute the data, which it will think are instructions.</p>
<p>Main has been changed to move register <code>si</code> (“Source index”, used as a data pointer) to the address of our message. The it calls <code>print</code>. The <code>print</code> subroutine is an elaboration on the “print character” code. The first instructions are the <code>lodsb</code> (“load string byte”), which loads the character at <code>si</code> into <code>al</code>, and increments <code>si</code>, moving it to the address of the next character. <code>cmp</code> “compares” the value in <code>al</code> to 0, and if it is 0 (meaning we are at the end of the string), it jumps to done and returns. Otherwise it jumps back to the loop label</p>
</div>
<div class="sidenotes">
<p><sup>2</sup> For linux users, it works fine with Wine.</p>
<p><sup>3</sup> A register is a storage location in the processor.</p>
<p><sup>4</sup> <code>0e</code> in hex, 14 in decimal</p>
<p><sup>5</sup> Specifically, 10h is a <em>BIOS routine</em>: A function that is defined in the BIOs, and can only be used in compatibility mode.</p>
</div>
</div>
<h2 id="real-mode">Real Mode</h2>
<div class="tufte-section">
<div class="main-text">
<h3 id="turning-our-hello-world-program-into-a-hello-world-bootloader">Turning our hello world program into a hello world bootloader</h3>
<p>Next we will turn our “hello world” program into a bootloader. That is, the program will be loaded by the BIOS and, when we boot the machine, it will show “Hello World!” on the screen.</p>
<p>Create a new folder / project <em>PeachOS</em>. Make a new file <em>boot.asm</em>, and add the following code:</p>
<pre class="assembly"><code>ORG 0x7c00
BITS 16

start:
    mov si, message
    call print
    jmp $

print:
    mov bx, 0
.loop:
    lodsb
    cmp al, 0
    je .done
    call print_char
    jmp .loop
.done:
    ret

print_char:
    mov ah, 0eh
    int 0x10
    ret

message: db &#39;Hello World!&#39;, 0

times 510-($ - $$) db 0 ; Pad to 510th byte
dw 0xAA55 ; dw=define word. Puts bootloader signal</code></pre>
<p>This is very similar to our non-bootloader code. There are a couple of organizational changes (<code>print_char</code> has been extracted into a subroutine, things have been moved around a bit), and a couple that are required to make this function as a bootloader. <code>ORG 0x7C00</code> sets the ‘origin’ or ‘starting location’ where your program is loaded into memory. Bootloaders are always loaded to <code>0x7C00</code>. <code>BITS 16</code> tells the processor that it should interpret the program in 16bit mode (“Real Mode”, or “Compatibility Mode”). The last two lines pad out the program with zeros, and then put the value <code>0x55AA</code> (the ‘signal’ that this is a bootloader) to the last 2 bytes of the sector.<sup>1</sup></p>
<p>Assemble your bootloader and boot it with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">nasm</span> -f bin ./boot.asm -o ./boot.bin</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ex">ndisasm</span> boot.bin <span class="co">#look at the machine code</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">qemu-system-x86_64</span> -hda ./boot.bin</a></code></pre></div>
</div>
<div class="sidenotes">
<p><sup>1</sup> Note that we say <code>0xAA55</code> in the code. This is because bytes are loaded ‘backwards’, with <code>55h</code> being loaded first.</p>
</div>
</div>
<h3 id="working-with-the-segmentation-memory-model">Working with the Segmentation Memory Model</h3>
<div class="tufte-section">
<div class="main-text">
<p>We have seen that the pointer registers in the processor are 2 bytes. That means your instruction pointer for example, which is 2 bytes, can point to memory locations <em>(addresses)</em> between bytes number 0 and (2^16) 65,535. However we’ve seen that in real mode, the processor has access to 1Mb of memory, or 1,048,576 bytes. How can we get our pointers to point to values above 65,535?</p>
<p>The answer is the <em>Segmentation Memory Model</em>. Memory is accessed by the combination of a <em>segment</em> and an <em>offset</em>. This is what the <em>segment registers</em> are for. There are 4 in the 8086: Code segment <code>cs</code>, Data segment <code>ds</code>, Extra segment <code>es</code> and Stack segment <code>ss</code>. The segment and offset can be combined to calculate the <em>absolute offset</em> (the actual memory location in RAM) by multiplying the segment by 16 (A left shift in hex) and adding the offset<sup>1</sup>. For example, if your segment is <code>0x7C0</code> and your offset (instruction pointer) and origin are both zero. The absolute memory address your program will start executing at is <code>0x7C0 * 16 = 0x7C00</code>. If your offset is <code>0xFF</code>, the absolute address will be <code>0x7CFF</code>. If segment is <code>0xF000</code> and offset is <code>0xFFFF</code>, the absolute memory address is <code>FFFFF</code>, or 1,048,575. This is how you address a megabyte of memory using two 16bit registers. Note that this model means that you can get to an address in multiple ways. For example, if your segment is <code>0x7CF</code> and offset is <code>0x0F</code>, the absolute address is also <code>0x7CFF</code>.</p>
<p>Different instructions in the processor’s instruction set use different combinations of registers to determine which absolute address to look at. For example, <code>lodsb</code> which we’ve already seen uses the data segment register and the source index register (shorthanded to <code>ds:si</code>).</p>
<p>Segment registers can be used in source using the following convention:</p>
<pre class="assembly"><code>mov byte al, [es:32]</code></pre>
<p>This will move the byte located in <code>es:32</code> into <code>al</code>.</p>
<p>One thing we need to do with our bootloader is to make sure all the segment registered are initialized to the values we want. The BIOS and interrupts can sometimes mess with these. Change the origin to 0. Give a <code>jmp</code> instruction to <code>0x7c0</code>, which changes the instruction pointer. Change data and extra segments to <code>0x7c0</code>. Change the stack segment to <code>0x00</code> and the stack <em>pointer</em> to <code>0x7c00</code>.</p>
<pre class="assembly"><code>ORG 0
BITS 16

jmp 0x7c0:start

start:
    cli ; clear interrupts
    mov ax, 0x7C0
    mov ds, ax
    mov es, ax
    mov ax, 0x00
    mov ss, ax
    mov sp, 0x7c00
    sti ; enables interrupts again
    mov si, message
    call print</code></pre>
<p>To reiterate what our code is now doing:</p>
<ol type="1">
<li>The CPU (running the BIOS) finds the value <code>0x55AA</code> in our binary ‘hard drive’</li>
<li>It loads that sector (0-512 bytes) into RAM starting at address <code>0x7c00</code>, and starts executing</li>
<li>The first instruction jumps to <code>0x7c0:start</code><sup>2</sup></li>
</ol>
</div>
<div class="sidenotes">
<p><sup>1</sup> Note that <code>ORG</code> or origin is also factored in.</p>
<p><sup>2</sup> Frankly I don’t get why - isn’t this redundant?</p>
</div>
</div>
<h3 id="interrupts-and-the-interrupt-vector-table">Interrupts and the Interrupt Vector Table</h3>
<div class="tufte-section">
<div class="main-text">
<p>Interrupts are like subroutines that you call through ‘interrupt numbers’ rather than memory addresses. There are interrupts in the BIOS - we saw <code>10h 0eh</code> prints a character to the screen - or they can be set up by the programmer. Interrupts are special because they halt the processor, save the current state (meaning what? the registers?) to the stack, execute the interrupt, then restore the pre-interrupt state.</p>
<p>The code for these interrupts are stored in RAM. The locations of the code are stored in the <em>interrupt vector table</em><sup>1</sup>, which starts right at the beginning of RAM at address <code>0x00</code>. There are 256 entries in numerical order, <code>0x00</code> to <code>0xFF</code>, and each contains a 4 bytes: a 2 byte OFFSET and a 2 byte SEGMENT. This means you can calculate the location in the IVT of any interrupt code with <code>code * 0x04</code>. Interrupt <code>0x13</code> is at <code>0x46</code>.</p>
<p>The processor can throw exceptions with interrupts. For example, if you try to divide by zero in an Intel processor, it will call interrupt 0.<sup>2</sup></p>
<p>In the following code, we <em>replace</em> interrupt 0 with our own subroutine, by replacing the entries in the IVT to point to the subroutine in memory. Running our bootloader in this state will cause the screen to show <code>AHello World!A</code> - the first <code>A</code> comes from our manual call to the <code>int 0</code>, and the second comes from our attempt to divide by zero, which causes the processor to run interrupt 0.</p>
<pre class="assembly"><code>start:
    ; snip
    mov word[ss:0x00], handle_zero ; Set offset to handle_word address
    mov word[ss:0x02], 0x07C0      ; set segment to 0x07c0 

    int 0 ; call interupt 0

    mov si, message
    call print

    mov ax, 0x00
    div ax ; try to divide by 0

    jmp $

handle_zero:
    mov ah, 0eh
    mov al, &#39;A&#39;
    mov bx, 0x00
    int 0x10
    iret

; snip</code></pre>
</div>
<div class="sidenotes">
<figure>
<img src="../../images/2021_03_21_kerneldev/IVT.png" alt="Interrupt Vector Table" /><figcaption>Interrupt Vector Table</figcaption>
</figure>
<p><sup>1</sup> All of this only applies to Real Mode. In Protected Mode, an “Interrupt Descriptor Table” is used instead. More on this later</p>
<p><sup>2</sup> wiki.osdev.org/exceptions is a great resource for learning more</p>
</div>
</div>
<h3 id="reading-from-disk">Reading from disk</h3>
<div class="tufte-section">
<div class="main-text">
<p>Next we will see how we can read data from a hard disk. Note that we’re not talking about accessing <em>files</em>. Files and the file system are implemented in the Kernel. Or to be more specific, the disk is ‘formatted’ with a particular file system data structure (FAT, EXT4 etc.), and the kernel has drivers which are able to interpret that data structure as files. As far as we are concerned, the disk consists of blocks of data called <em>sectors</em><sup>1</sup>. A sector consists of 512 contiguous bytes. These sectors are read and written in sector blocks, not by accessing individual bytes.</p>
<p>The old way of addressing disk sectors is the <em>Cylinder Head Sector</em> (CHS) system. This is from when disks were spinning magnetic plates arranged in cylinders. You need to specify the cylinder, head, sector and track you want to read from. This was pretty complicated, and it is no longer really used. The modern way is called <em>Logical Block Address</em> (LBA). In LBA you just specify the sector number you want to get. LBA 0 is the first sector on the disk, etc.<sup>2</sup></p>
<h3 id="some-housekeeping-before-we-actually-read-from-the-disk">Some housekeeping before we actually read from the disk</h3>
<p>First create a text file and put in it whatever you want. This is going to be the thing that gets read from the disk. Create a <em>Makefile</em><sup>3</sup>.</p>
<pre class="make"><code>all:
    nasm -f bin ./boot.asm -o ./boot.bin
    dd if=./message.txt &gt;&gt; ./boot.bin
    dd if=/dev/zero bs=512 count=1 &gt;&gt; ./boot.bin</code></pre>
<p>The first line is same assemble command we’ve already been using. The second line puts the content of <em>message.txt</em> onto the end of our binary, and the third pads the binary out with null characters until it’s 512 bytes, and therefore a valid sector. You can type <code>make</code> at the command line to compile the project. You can see the content of the binary with <code>hexdump -C ./boot.bin &gt; hex.txt</code>, and opening the text file.</p>
<h3 id="time-to-actually-read-from-the-disk">Time to actually read from the disk</h3>
<p>We’ll be using interrupt <code>13h/02h</code>: “Disk - Read Sectors into Memory”. Looking at the expected register values that <a href="http://www.ctyme.com/intr/rb-0607.htm">Ralph Brown</a> provides<sup>4</sup> we can get to the follow code:</p>
<pre class="assembly"><code>    mov ah, 02h
    mov al, 1
    mov ch, 0
    mov dh, 0
    mov cl, 2
    mov bx, buffer
    int 0x13
    jc error ; if carry flag is set, meaning load failed

    mov si, buffer
    call print

; snip to end of file

error_message: db &#39;Failed to load sector&#39;, 0

times 510-($ - $$) db 0 ; Pad to 510th byte
dw 0xAA55 ; dw=define word. Puts bootloader signal

buffer:</code></pre>
<p>Here we set up the registers as they need to be to read our message from the 2nd sector (<code>cl</code>) of the disk into the <code>buffer</code> label in memory<sup>5</sup>. Then we call the interrupt <code>0x13</code>. <code>jc</code> handles the error condition.</p>
</div>
<div class="sidenotes">
<p><sup>1</sup> We already encountered sectors when talking about how the bootloader is loaded.</p>
<figure>
<img src="../../images/2021_03_21_kerneldev/disk.png" alt="Disk" /><figcaption>Disk</figcaption>
</figure>
<p><sup>2</sup> Since you can only read in sectors, to calculate a specific place on the disk using LBA you need to calculate the sector and the offset. This is simply a matter of getting the quotient and the modulus. So to get to byte 58376 you calculate the LBA sector by <code>58376/512=114</code>, and the offset as <code>58376%512=8</code></p>
<p><sup>3</sup> Make is a language unto itself, intended to simplify the compilation of project with multiple files.</p>
<p><sup>4</sup> <code>AH</code> = 02h, <code>AL</code> = number of sectors to read, <code>CH</code> = cylinder number, <code>CL</code> = sector number, <code>DH</code> = head number, <code>ES:BX</code> -&gt; data buffer. Return: <code>CF</code> set on error</p>
<p><sup>5</sup> Note that the data is put into <code>ES:BX</code>, the Extra Segment. We have set this to <code>0x7c0</code>, which is the right place.</p>
</div>
</div>
<h2 id="protected-mode">Protected Mode</h2>
<div class="tufte-section">
<div class="main-text">
<p>Up to now we have been working in “Real Mode” or “Compatibility Mode”. This is a very limited mode which the processor initially boots into. It executes 16 bit instructions and registers, can only address 1Mb of RAM, and has no memory protection.</p>
<p>Our next step will be to change into <em>“Protected Mode”</em>. We move to 32bit instructions and registers, and have 4Gb address space. Most importantly it significantly changes the memory model, and <em>protects</em> that memory, limiting how programs can access memory and hardware. <em>Ring 0</em> is the most privileged, and is where the kernel operates. There are few limits imposed here. You put the processor into <em>Ring 3</em> when running user applications, limiting them to changing memory in their own ‘block’, preventing them from accessing hardware directly, and limiting the instructions they can run, such as IO.</p>
<p>User programs communicate with the kernel by causing an interrupt. The interrupt will pass control to the kernel, which will switch back to Ring 0, do what it has to do, then pass control back to the user application after switching back to Ring 3.</p>
<h3 id="memory-schemes-change-when-you-are-in-protected-mode">Memory schemes change when you are in Protected Mode</h3>
<p>In Real Mode, our memory scheme was the Segmentation Model, using the 16bit segment registers to address memory. Protected Mode uses the <em>Paging Model</em>. The paging model is an abstraction on top of physical memory. You work with ‘virtual’ blocks (pages) of memory that map back to different physical locations in RAM. As a result, different programs can ‘believe’ they are loaded at the same address, so they don’t need to think about where other programs are, because they can’t see or access them. Programs are effectively sandboxed to the memory space that the kernel has assigned them.<sup>1</sup></p>
<p>We also switching from using segment registers to <em>selector</em> registers for addressing memory. Each selector points to a data structure which describes a memory range and the permissions of that range.</p>
</div>
<div class="sidenotes">
<figure>
<img src="../../images/2021_03_21_kerneldev/rings.png" alt="Rings" /><figcaption>Rings</figcaption>
</figure>
<figure>
<img src="../../images/2021_03_21_kerneldev/selectors.png" alt="Selectors" /><figcaption>Selectors</figcaption>
</figure>
<p><sup>1</sup> Any virtual and physical address need to be divisible by 4,096, which is the basic block size.</p>
</div>
</div>
<h3 id="switching-to-protected-mode">Switching to Protected Mode</h3>
<div class="tufte-section">
<div class="main-text">
<p>We will use the instructions per the <a href="https://wiki.osdev.org/Protected_Mode">OSDev wiki</a>. The instruction called <code>lgdt</code> is the critical one. This stands for “Load Global Descriptor Table”.</p>
<pre class="assembly"><code>cli            ; disable interrupts
lgdt [gdtr]    ; load GDT register with start address of Global Descriptor Table
mov eax, cr0 
or al, 1       ; set PE (Protection Enable) bit in CR0 (Control Register 0)
mov cr0, eax
 
; Perform far jump to selector 08h (offset into GDT, pointing at a 32bit PM code segment descriptor) 
; to load CS with proper PM32 descriptor)
jmp 08h:PModeMain
 
PModeMain:
; load DS, ES, FS, GS, SS, ESP</code></pre>
<p>The <a href="https://wiki.osdev.org/Global_Descriptor_Table"><em>Global Descriptor Table</em></a> (GDT) contains entries telling the CPU about memory Segments. The GDT contains pointers to GDT Entries - the descriptors themselves. The GDT entries describe the memory and the access rights. While we will need to set this up, we’re going gloss over a lot of the detail and use default values, because our kernel is going to use paging, meaning after a point this will no longer be relevant. The following is the relevant code, which starts after the <code>start</code> block.</p>
<pre class="assembly"><code>.load_protected:
    cli
    lgdt[gdt_descriptor]
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax
    jmp CODE_SEG:load32 ; we&#39;ll define what CODE_SEG is later

gdt_start:
gdt_null:
    dd 0x0
    dd 0x0

; offset 0x8
gdt_code:     ; CS should point to this
    dw 0xFFFF ; Seg Limit first 0-15 bits
    dw 0      ; base first 0-15 bits
    db 0      ; base 16-23 bits
    db 0x9a   ; access byte
    db 11001111b ; hi+lo 4bit flags
    db 0

; offset 0x10
gdt_data:     ; DS/SS/ES/FS/GS
    dw 0xFFFF ; Seg Limit first 0-15 bits
    dw 0      ; base first 0-15 bits
    db 0      ; base 16-23 bits
    db 0x92   ; access byte
    db 11001111b ; hi+lo 4bit flags
    db 0

gdt_end:
gdt_descriptor:
    dw gdt_end - gdt_start-1
    dd gdt_start</code></pre>
<p>Starting from the <code>gdt_start</code> label: The first entry in the GDT is <code>NULL</code>. The two <code>dd 0x0</code> creates a “null segment” 8 bytes/64bits of nulls. From <code>gdt_code</code> we create our entry, which is the selector which will link to our <em>Code Segment</em>. Again, don’t worry too much about what these are for now, they are basically default values. The access byte is a bitmask containing flags. We put in another entry, <code>gdt_data</code>, which will be linked to all of our other Segments: Data, Stack, Extra, and two General Segments, G and F. It’s identical with the exception of the access byte.</p>
<p>Next we provide some descriptors, firstly the size of our GDT, and secondly the location of the GDT in the program. These will be used by <code>lgdt</code>. Finally we set up our <code>load_protected</code> block. This loads the GDT, defaults the control register <code>cr0</code> to <code>0x1</code> if null, and jumps to <code>CODE_SEG:load32</code>.</p>
<p>Before actually writing <code>load32</code> we need to do a couple of things. One thing we need to change is our origin, which is our offset. Currently this is set to 0. Previously this was fine, since we jumped straight to where the code was being loaded in memory: segment <code>0x7c0</code>. Now, however, our GDT descriptor will point to <code>0:gdt_descriptor</code>. So change the ORG to <code>0x7C00</code>. A couple of other things will need to change in sympathy. We also want to define <code>CODE_SEG</code> and <code>DATA_SEG</code>, which will point to entries in our GDT.</p>
<pre class="assembly"><code>ORG 0x7C00 ; changed from 0
BITS 16

CODE_SEG equ gdt_code - gdt_start ; defines CODE_SEG as the offset from GDT start
DATA_SEG equ gdt_data - gdt_start ; same for DATA_SEG

jmp 0:start ; absolute 0x7c0 (start is at 0x7c05)

; since our origin is now 0x7c00, our segments need to 0x00 (???)
start: 
    cli 
    mov ax, 0x00
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7c00
    sti </code></pre>
<p>Now for <code>load32</code>. First, change into 32bit mode. Here we mostly just setup registers (Code segment register is already set by the origin?). We also point the stack frame/stack pointer registers <code>ebp</code> and <code>esp</code>.</p>
<pre class="assembly"><code>[BITS 32]
load32:
    mov ax, DATA_SEG
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov ebp, 0x00200000
    mov esp, ebp
    jmp $</code></pre>
<h3 id="testing">Testing</h3>
<p>We can test this with the GNU Debugger, gdp. You might need to install it.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">$ <span class="fu">gdb</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">target</span> remote <span class="kw">|</span> <span class="ex">qemu-system-x86_64</span> -hda ./bin/boot.bin -S -gbd stdio</a></code></pre></div>
<p>Enter <code>c</code> to continue, your <code>qemu</code> should boot. Send a <code>SIGINT</code> with <code>Ctrl+c</code>. You should see: <code>Program received signal SIGINT, Interrupt. 0x0000000000007c5b in ?? ()</code>. This indicates the program is currently executing at RAM location <code>0x7c5b</code>. If you type <code>layout asm</code>, you can see the value in memory at <code>0x7c5b</code>, and see that it is the infinite jump <code>jmp $</code> at the end of our load routine. You can also type <code>info registers</code> and see that your code segment register is set to 8, and the other ones to 16 (<code>0x10</code>).</p>
<p>You are now in protected / 32 bit mode! Note that this means you can’t talk to the BIOS directly anymore.</p>
<h3 id="enabling-a20-line">Enabling A20 Line</h3>
<p>The <a href="https://wiki.osdev.org/A20_Line">A20 Line</a> is necessary to access the 21st bit (bit 20) of any 32bit/4byte block. The reason that this is disabled by default is some obscure compatibility issue, which isn’t important. You can read more about it at the above link if you want. The method for doing this is very simple: 3 instructions in the <code>load32</code> section. The <code>in</code> and <code>out</code> instructions read and write to processor bus respectively. Test this with gdb.</p>
<pre class="assemly"><code>    ;snip
    mov esp, ebp

    ; enable A20 line
    in al, 0x92
    or al, 2
    out 0x92, al

    jmp $</code></pre>
</div>
<div class="sidenotes">
<figure>
<img src="../../images/2021_03_21_kerneldev/gdt.png" alt="GDT Entry" /><figcaption>GDT Entry</figcaption>
</figure>
</div>
</div>
<h2 id="building-a-c-compiler">Building a C Compiler</h2>
<div class="tufte-section">
<div class="main-text">
<p>Assembly is all well and good, but it’s a pain to write an OS using it. Ideally we want to write it in C. To do this, we need a C compiler, which will turn C into Assembly and then into machine code. We will be compiling the GCC compiler. We can’t use GCC directly, because it’s compiled for linux. What we need is a <a href="https://wiki.osdev.org/GCC_Cross-Compiler"><em>cross compiler</em></a>. That page has a full guide, and the video goes through the steps, so I won’t replicate it here, but bear in mind it takes a <strong>long time</strong>, like 1 hour plus.</p>
<p>Next we need to write a build script that will make working with C directly easier by setting the path variable. Create a <code>build.sh</code>, and add the following, and make it executable with <code>chmod +x build.sh</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1"><span class="co">#/bin/bash</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="bu">export</span> <span class="va">PREFIX=</span><span class="st">&quot;</span><span class="va">$HOME</span><span class="st">/opt/cross&quot;</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="bu">export</span> <span class="va">TARGET=</span>i686-elf</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$PREFIX</span><span class="st">/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="fu">make</span> all</a></code></pre></div>
<p>The rest of this section is going to revolve around breaking out our kernel into it’s own file. We’ll end up with a <code>boot.asm</code> and <code>kernel.asm</code>, and then we will combine the output binaries of these two into an <code>os.bin</code>, which will be our final image, with the bootloader being the first sector and the kernel being the remainder, with the booloader loading the kernel into memory.</p>
<pre class="ld"><code>ENTRY(_start)
OUTPUT_FORMAT(binary)
SECTIONS
{
  . = 1M;
  .text : 
  {
    *(.text)
  }

  .rodata :
  {
    *(.rodata)
  }

  .data :
  {
    *(.data)
  }

  .bss :
  {
    *(COMMON)
    *(.bss)
  }
}</code></pre>
<p>Don’t worry too much about what all this does for now, but in summary we are saying that our sections (and therefore our kernel) will start at memory address <code>1M</code>: address at 1Mb, 1,048,576 in decimal or 100,000 hex.</p>
<p>Next we modify our makefile so it builds the whole project:</p>
<pre class="make"><code>FILES = ./build/kernel.asm.o

all: ./bin/boot.bin ./bin/kernel.bin
    rm -f ./bin/os.bin
    dd if=./bin/boot.bin &gt;&gt; ./bin/os.bin
    dd if=./bin/kernel.bin &gt;&gt; ./bin/os.bin
    dd if=/dev/zero bs=512 count=100 &gt;&gt; ./bin/os.bin

./bin/kernel.bin: $(FILES)
    i686-elf-ld -g -relocatable $(FILES) -o ./build/kernelfull.o
    i686-elf-gcc -T ./src/linker.ld -o ./bin/kernel.bin -ffreestanding -O0 -nostdlib ./build/kernelfull.o

./bin/boot.bin: ./src/boot/boot.asm
    nasm -f bin ./src/boot/boot.asm -o ./bin/boot.bin

./build/kernel.asm.o: ./src/kernel.asm
    nasm -f elf -g ./src/kernel.asm -o ./build/kernel.asm.o

clean:
    rm -f ./bin/boot.bin
    rm -f ./bin/kernel.bin
    rm -f $(FILES)
    rm -f ./build/kernelfull.o</code></pre>
<p>Again, the details of how make works are not in scope of this course, but in summary we are building the kernel asm into an <code>asm.o</code> (an “object file”), building that into a <code>kernel.bin</code> using gcc and our linker, building <code>boot.bin</code> and finally combining those two bins into <code>os.bin</code>. Note in particular the <code>-g</code> flag that is used a couple of times. This will allow us to use debugging symbols later on. Note also the padding of nulls we add to the end of <code>os.bin</code>: out to 100 sectors of 512 bytes. This will allow our kernel to grow without us having to change anything.</p>
<p>Back in <code>kernel.asm</code>, there is a reference to <code>DATA_SEG</code>, but this is no longer defined. So add it in. Recall that the addresses correspond to the entries in the Global Descriptor Table. The <code>global _start</code> corresponds to our <code>ENTRY(_start)</code> in the linker:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb20-1" title="1">[BITS <span class="dv">32</span>]</a>
<a class="sourceLine" id="cb20-2" title="2">global _start</a>
<a class="sourceLine" id="cb20-3" title="3">CODE_SEG <span class="pp">equ</span><span class="bn"> 0x08</span></a>
<a class="sourceLine" id="cb20-4" title="4">DATA_SEG <span class="pp">equ</span><span class="bn"> 0x10</span></a>
<a class="sourceLine" id="cb20-5" title="5"></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="fu">_start:</span></a>
<a class="sourceLine" id="cb20-7" title="7">    <span class="bu">mov</span> <span class="kw">ax</span>, DATA_SEG</a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="co">; snip</span></a></code></pre></div>
<h3 id="next-we-need-to-write-a-driver-and-load-the-kernel-into-memory">Next we need to write a driver and load the Kernel into memory</h3>
<p>We need to load the Kernel into memory. Given we are now in protected mode, we can’t access the BIOS function like we did earlier, so we need to write a quick disk driver, which will tell our bootloader how to interact with the ATA Protocol disk controller by spitting data onto the processor bus. Add the following to your <code>boot.asm</code>. Don’t worry too much about the detail beyond the comments</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode asm"><code class="sourceCode fasm"><a class="sourceLine" id="cb21-1" title="1">[BITS <span class="dv">32</span>]</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="fu">load32:</span></a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="bu">mov</span> <span class="kw">eax</span>, <span class="dv">1</span>         <span class="co">; LBA: starting sector we want to load from disk, 1</span></a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="bu">mov</span> <span class="kw">ecx</span>, <span class="dv">100</span>       <span class="co">; sector we want to load to, because we wrote 100 sectors of nulls in make</span></a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="bu">mov</span> <span class="kw">edi</span><span class="bn">, 0x0100000 </span><span class="co">; 1Mb in hex, where we want to load our Kernel into RAM </span></a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="bu">call</span> ata_lba_read  <span class="co">; load the kernel to memory</span></a>
<a class="sourceLine" id="cb21-7" title="7">    <span class="bu">jmp</span> CODE_SEG:<span class="bn">0x0100000 </span><span class="co">; jump to the memory address to where we loaded the kernel</span></a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="co">; this is like a &#39;dummy disk driver&#39; to load our kernel. We&#39;ll write a proper one in C later</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="fu">ata_lba_read:</span></a>
<a class="sourceLine" id="cb21-11" title="11">    <span class="bu">mov</span> <span class="kw">ebx</span>, <span class="kw">eax</span> <span class="co">; backup LBA</span></a>
<a class="sourceLine" id="cb21-12" title="12">    <span class="co">; Send highest 8 bits of LBA to hard disk controller</span></a>
<a class="sourceLine" id="cb21-13" title="13">    <span class="bu">shr</span> <span class="kw">eax</span>, <span class="dv">24</span>   <span class="co">; shift eax 24 bits to the right</span></a>
<a class="sourceLine" id="cb21-14" title="14">    <span class="bu">or</span> <span class="kw">eax</span>, <span class="bn">0xE0</span>  <span class="co">; selects the master drive</span></a>
<a class="sourceLine" id="cb21-15" title="15">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F6 </span><span class="co">; port on the Hard Disk</span></a>
<a class="sourceLine" id="cb21-16" title="16">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-17" title="17"></a>
<a class="sourceLine" id="cb21-18" title="18">    <span class="co">; Send total sectors</span></a>
<a class="sourceLine" id="cb21-19" title="19">    <span class="bu">mov</span> <span class="kw">eax</span>, <span class="kw">ecx</span></a>
<a class="sourceLine" id="cb21-20" title="20">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F2</span></a>
<a class="sourceLine" id="cb21-21" title="21">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-22" title="22"></a>
<a class="sourceLine" id="cb21-23" title="23">    <span class="co">; send some more bits to the disk controller</span></a>
<a class="sourceLine" id="cb21-24" title="24">    <span class="bu">mov</span> <span class="kw">eax</span>, <span class="kw">ebx</span> <span class="co">; restore backup LBA</span></a>
<a class="sourceLine" id="cb21-25" title="25">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F3</span></a>
<a class="sourceLine" id="cb21-26" title="26">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-27" title="27"></a>
<a class="sourceLine" id="cb21-28" title="28">    <span class="bu">mov</span> <span class="kw">eax</span>, <span class="kw">ebx</span></a>
<a class="sourceLine" id="cb21-29" title="29">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F4</span></a>
<a class="sourceLine" id="cb21-30" title="30">    <span class="bu">shr</span> <span class="kw">eax</span>, <span class="dv">8</span></a>
<a class="sourceLine" id="cb21-31" title="31">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-32" title="32"></a>
<a class="sourceLine" id="cb21-33" title="33">    <span class="co">; send upper 16 bits of LBA</span></a>
<a class="sourceLine" id="cb21-34" title="34">    <span class="bu">mov</span> <span class="kw">eax</span>, <span class="kw">ebx</span></a>
<a class="sourceLine" id="cb21-35" title="35">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F5</span></a>
<a class="sourceLine" id="cb21-36" title="36">    <span class="bu">shr</span> <span class="kw">eax</span>, <span class="dv">16</span></a>
<a class="sourceLine" id="cb21-37" title="37">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-38" title="38"></a>
<a class="sourceLine" id="cb21-39" title="39">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1f7</span></a>
<a class="sourceLine" id="cb21-40" title="40">    <span class="bu">mov</span> <span class="kw">al</span><span class="bn">, 0x20</span></a>
<a class="sourceLine" id="cb21-41" title="41">    <span class="bu">out</span> <span class="kw">dx</span>, <span class="kw">al</span></a>
<a class="sourceLine" id="cb21-42" title="42"></a>
<a class="sourceLine" id="cb21-43" title="43">    <span class="co">; read sectors</span></a>
<a class="sourceLine" id="cb21-44" title="44"><span class="fu">.next_sector:</span></a>
<a class="sourceLine" id="cb21-45" title="45">    <span class="bu">push</span> <span class="kw">ecx</span></a>
<a class="sourceLine" id="cb21-46" title="46"></a>
<a class="sourceLine" id="cb21-47" title="47">    <span class="co">;checking if we need to read</span></a>
<a class="sourceLine" id="cb21-48" title="48"><span class="fu">.try_again:</span></a>
<a class="sourceLine" id="cb21-49" title="49">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1f7</span></a>
<a class="sourceLine" id="cb21-50" title="50">    <span class="bu">in</span> <span class="kw">al</span>, <span class="kw">dx</span></a>
<a class="sourceLine" id="cb21-51" title="51">    <span class="bu">test</span> <span class="kw">al</span>, <span class="dv">8</span></a>
<a class="sourceLine" id="cb21-52" title="52">    <span class="bu">jz</span> .try_again</a>
<a class="sourceLine" id="cb21-53" title="53"></a>
<a class="sourceLine" id="cb21-54" title="54">    <span class="co">; read 256 words at a time</span></a>
<a class="sourceLine" id="cb21-55" title="55">    <span class="bu">mov</span> <span class="kw">ecx</span>, <span class="dv">256</span></a>
<a class="sourceLine" id="cb21-56" title="56">    <span class="bu">mov</span> <span class="kw">dx</span><span class="bn">, 0x1F0</span></a>
<a class="sourceLine" id="cb21-57" title="57">    rep <span class="bu">insw</span> <span class="co">; input word from port per DX into memloc ES:EDI - we&#39;ve set EDI to 1Mb</span></a>
<a class="sourceLine" id="cb21-58" title="58">    <span class="bu">pop</span> <span class="kw">ecx</span></a>
<a class="sourceLine" id="cb21-59" title="59">    <span class="bu">loop</span> .next_sector</a>
<a class="sourceLine" id="cb21-60" title="60">    <span class="co">; end of reading sectors into memory</span></a>
<a class="sourceLine" id="cb21-61" title="61">    <span class="bu">ret</span></a></code></pre></div>
<h3 id="alignment-and-solving-alignment-issues-with-c-code-and-asm.">Alignment and solving alignment issues with C code and ASM.</h3>
</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<h2 id="bits-byte-binary-and-hex">Bits, byte, binary and hex</h2>
<ul>
<li>A bit is a single binary digit 0 or 1.</li>
<li>2 binary digits can represent 4 unique values: <code>00</code>, <code>01</code>, <code>10</code>, <code>11</code></li>
<li>n binary digits can represent 2^n unique values.</li>
<li>4 binary digits can represent 2^4 = 16 unique values</li>
<li>8 binary digits can represent 2^8 = 256 values.</li>
<li>8 bits, represented by an 8 digit binary, is a byte, which can take one of 256 values.</li>
<li>A hex digit can take the values <code>0-F</code>, or 16 possible values</li>
<li>A single hex digit is equivalent to 4 binary digits</li>
<li>Two hex digits (<code>00</code> to <code>FF</code>) represent 16^2 = 256 values. Therefore 2 hex digits represents one byte.</li>
<li>4 hex digits (<code>0000</code> to <code>FFFF</code>) represent 2 bytes, or 16 bits.</li>
<li>Each memory location can hold a single byte, or 2 digit hex number.</li>
</ul>
</body>
</html>
