<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kernel Development</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Kernel Development</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#what-is-memory">What is memory?</a></li>
<li><a href="#the-boot-process">The Boot Process</a></li>
<li><a href="#getting-setup-for-kernel-development">Getting setup for Kernel development</a></li>
<li><a href="#assembly-language">Assembly language</a></li>
<li><a href="#a-hello-world-bootloader">A Hello World Bootloader</a></li>
<li><a href="#segmentation-memory-model">Segmentation Memory Model</a></li>
</ul>
</nav>
<p>This is based on a <a href="https://dragonzap.com/course/developing-a-multithreaded-kernel-from-scratch?coupon=YOUTUBEKERNEL2022">course</a> which guides the reader through the development of a full OS kernel, from a Hello World Bootloader to a multitasking kernel with a FAT16 file system. The first 11 lessons are available for free on <a href="https://www.youtube.com/watch?v=HNIg3TXfdX8&amp;list=PLrGN1Qi7t67V-9uXzj4VSQCffntfvn42v">YouTube</a></p>
<h2 id="what-is-memory">What is memory?</h2>
<div class="tufte-section">
<div class="main-text">
<p>Memory is a piece of hardware that allows computers to store information. Programs can read and write to <em>Random Access Memory</em> (RAM). It’s only used for temporary storage, such as for variable storage of the programs you write. RAM is wiped when you shut down the computer. <em>Read Only Memory</em> (ROM) does <em>not</em> vanish when you shut down the computer. But as the name suggests, you can’t write to it. In a home PC, the BIOS program is stored in ROM.</p>
<p>Memory is generally accessed in a linear fashion. The data is stored in order. The way your processor accesses memory abstracts this.</p>
</div>
<div class="sidenotes">

</div>
</div>
<h2 id="the-boot-process">The Boot Process</h2>
<div class="tufte-section">
<div class="main-text">
<p>The boot process has three steps:</p>
<ol type="1">
<li>The BIOS<sup>1</sup> program is executed from ROM/BIOS Chip</li>
<li>The BIOS loads the <em>Bootloader</em> into memory address <code>0x7C00</code></li>
<li>The Bootloader loads the Kernel</li>
</ol>
<p>When the computer is switched on, the CPU will read from the BIOS ROM and start executing instructions it finds there. The BIOS usually loads itself into RAM for performance reasons and will continue to execute from there. The BIOS also identifies and initializes the computer’s hardware, such as disk drivers.</p>
<p>The final thing the BIOS does is try to find a Bootloader. It searches all available storage mediums - USB drives, hard disks - for the magic boot signature <code>0x55AA</code>. It will look in the last bytes of the first sector<sup>2</sup>, and if the signature is found, it will load that sector into address <code>0x7C00</code>, and the CPU will start to execute from that address.</p>
<p>When a computer first boots, it does so in <em>“Real Mode”</em>. This is a very limited ‘compatibility’ mode, with access to only 1Mb of memory, and it can only execute 16 bit code. The Bootloader is a small program whose job is to put the computer into <em>“Protected Mode”</em>, which allows 32 bit code and access to 4Gb of memory, and then to load the kernel of an operating system.</p>
<p>The BIOS contains routines that the bootloader uses to boot the kernel. The interfaces of BIOS routines are generic and standardized across manufacturers.</p>
</div>
<div class="sidenotes">
<p><sup>1</sup> Basic Input Output System</p>
<figure>
<img src="../../images/2021_03_21_kerneldev/booting.png" alt="booting" /><figcaption>booting</figcaption>
</figure>
<p><sup>2</sup> A sector is a block of storage. For example, a hard disk is made up of 512 byte sectors. The BIOS will look in the byte addresses 511 and 512 of the sector.</p>
</div>
</div>
<h2 id="getting-setup-for-kernel-development">Getting setup for Kernel development</h2>
<div class="tufte-section">
<div class="main-text">
<p>All development will be done on Ubuntu Linux. First, make sure your repositories are up to date with. Then, install nasm<sup>1</sup>. Finally, we will use the QEmu emulator to run our bootloader and kernel. Test that it runs using the below commands. A new window will pop up, but since there are no disks attached it won’t be able to boot.</p>
<pre><code>sudo apt update
sudo apt install nasm

sudo apt install qemu-system-x86
qemu-system-x86_64</code></pre>
</div>
<div class="sidenotes">
<p><sup>1</sup> NASM is the “Netwide Assembler”, and assembler for the x86 CPU architecture, compatible with nearly every modern platform. https://nasm.us</p>
</div>
</div>
<h2 id="assembly-language">Assembly language</h2>
<div class="tufte-section">
<div class="main-text">
<p>This is a short refresher on what assembly language is. Or, for me, basically an introduction to it, since I’ve never written it before.</p>
<p>Your processor has an <em>instruction set</em>, or machine codes. Assembly language gets passed through an <em>assembler</em>, and machine codes your processor understands come out the other side. Use <a href="https://emu8086-microprocessor-emulator.en.softonic.com/">Emu8086</a> to easily test assembly programs.<sup>2</sup></p>
<p>Write the following program in your emulator:</p>
<pre class="assembly"><code>mov ah, 0eh
mov al, &#39;A&#39;
int 10h</code></pre>
<p>This is a program that outputs ‘A’ to the screen. <code>mov X Y</code> moves data Y to register<sup>3</sup> X. <code>ah</code> (“Accumulator High”) and <code>al</code> (“Accumulator Low”) are registers storing one byte. So here we move <code>0eh</code><sup>4</sup> into <code>ah</code>, and the character ‘A’ (65) into <code>al</code>. <code>int X</code> means <em>“interrupt with code X”</em>. The code <code>10h</code> outputs things to the screen<sup>5</sup>.</p>
<p>So we have a program that outputs a <em>character</em> to a screen. Now we need to output multiple characters. Here is our next program.</p>
<pre class="assembly"><code>jmp main

message: db &#39;Hello World!&#39;, 0

print:
    mov ah, 0eh
._loop:
    lodsb
    cmp al, 0
    je .done
    int 10h
    jmp ._loop
.done:
    ret

main:
    mov si, message
    call print</code></pre>
<p>The first thing to point out is that assembly always executes top-to-bottom unless you specifically tell it to jump to somewhere else. This is done with <em>labels</em>. These are the words that end with colons, like <code>main:</code>. For example <code>print</code> is a subroutine, and when it is called with <code>call print</code>, the program will start executing at this point.</p>
<p>The line <code>message: db 'Hello World!', 0</code>, puts a block of data representing the bytes ‘Hello World!’ at the starting memory location (<code>db</code> mean data bytes I think). The zero at the end is the ‘null’ terminator. We have to put <code>jmp main</code> above that, otherwise the processor will try to execute the data, which it will think are instructions.</p>
<p>Main has been changed to move register <code>si</code> (“Source index”, used as a data pointer) to the address of our message. The it calls <code>print</code>. The <code>print</code> subroutine is an elaboration on the “print character” code. The first instructions are the <code>lodsb</code> (“load string byte”), which loads the character at <code>si</code> into <code>al</code>, and increments <code>si</code>, moving it to the address of the next character. <code>cmp</code> “compares” the value in <code>al</code> to 0, and if it is 0 (meaning we are at the end of the string), it jumps to done and returns. Otherwise it jumps back to the loop label</p>
</div>
<div class="sidenotes">
<p><sup>2</sup> For linux users, it works fine with Wine.</p>
<p><sup>3</sup> A register is a storage location in the processor.</p>
<p><sup>4</sup> <code>0e</code> in hex, 14 in decimal</p>
<p><sup>5</sup> Specifically, 10h is a <em>BIOS routine</em>: A function that is defined in the BIOs, and can only be used in compatibility mode.</p>
</div>
</div>
<h2 id="a-hello-world-bootloader">A Hello World Bootloader</h2>
<div class="tufte-section">
<div class="main-text">
<p>Next we will turn our “hello world” program into a bootloader. That is, the program will be loaded by the BIOS and, when we boot the machine, it will show “Hello World!” on the screen.</p>
<p>Create a new folder / project <em>PeachOS</em>. Make a new file <em>boot.asm</em>, and add the following code:</p>
<pre class="assembly"><code>ORG 0x7c00
BITS 16

start:
    mov si, message
    call print
    jmp $

print:
    mov bx, 0
.loop:
    lodsb
    cmp al, 0
    je .done
    call print_char
    jmp .loop
.done:
    ret

print_char:
    mov ah, 0eh
    int 0x10
    ret

message: db &#39;Hello World!&#39;, 0

times 510-($ - $$) db 0 ; Pad to 510th byte
dw 0xAA55 ; dw=define word. Puts bootloader signal</code></pre>
<p>This is very similar to our non-bootloader code. There are a couple of organizational changes (<code>print_char</code> has been extracted into a subroutine, things have been moved around a bit), and a couple that are required to make this function as a bootloader. <code>ORG 0x7C00</code> sets the ‘origin’ or ‘starting location’ where your program is loaded into memory. Bootloaders are always loaded to <code>0x7C00</code>. <code>BITS 16</code> tells the processor that it should interpret the program in 16bit mode (“Real Mode”, or “Compatibility Mode”). The last two lines pad out the program with zeros, and then put the value <code>0x55AA</code> (the ‘signal’ that this is a bootloader) to the last 2 bytes of the sector.<sup>1</sup></p>
<p>Assemble your bootloader and boot it with</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">nasm</span> -f bin ./boot.asm -o ./boot.bin</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ex">ndisasm</span> boot.bin <span class="co">#look at the machine code</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="ex">qemu-system-x86_64</span> -hda ./boot.bin</a></code></pre></div>
</div>
<div class="sidenotes">
<p><sup>1</sup> Note that we say <code>0xAA55</code> in the code. This is because bytes are loaded ‘backwards’, with <code>55h</code> being loaded first.</p>
</div>
</div>
<h2 id="segmentation-memory-model">Segmentation Memory Model</h2>
<div class="tufte-section">
<div class="main-text">
<p>We have seen that the pointer registers in the processor are 2 bytes. That means your instruction pointer for example, which is 2 bytes, can point to memory locations <em>(addresses)</em> between bytes number 0 and (2^16) 65,535. However we’ve seen that in real mode, the processor has access to 1Mb of memory, or 1,048,576 bytes. How can we get our pointers to point to values above 65,535?</p>
<p>The answer is the <em>Segmentation Memory Model</em>. Memory is accessed by the combination of a <em>segment</em> and an <em>offset</em>. This is what the <em>segment registers</em>. There are 4 in the 8086: Code segment <code>cs</code>, Data segment <code>ds</code>, Extra segment <code>es</code> and Stack segment <code>ss</code>. The segment and offset can be combined to calculate the <em>absolute offset</em> (the actual memory location in RAM) by multiplying the segment by 16 (A left shift in hex) and adding the offset<sup>1</sup>. For example, if your segment is <code>0x7C0</code> and your offset (instruction pointer) and origin are both zero. The absolute memory address your program will start executing at is <code>0x7C0 * 16 = 0x7C00</code>. If your offset is <code>0xFF</code>, the absolute address will be <code>0x7CFF</code>. If segment is <code>0xF000</code> and offset is <code>0xFFFF</code>, the absolute memory address is <code>FFFFF</code>, or 1,048,575. This is how you address a megabyte of memory using two 16bit registers. Note that this model means that you can get to an address in multiple ways. For example, if your segment is <code>0x7CF</code> and offset is <code>0x0F</code>, the absolute address is also <code>0x7CFF</code>.</p>
<p>Different instructions in the processor’s instruction set use different combinations of registers to determine which absolute address to look at. For example, <code>lodsb</code> which we’ve already seen uses the data segment register and the source index register (shorthanded to <code>ds:si</code>).</p>
<p>Segment registers can be used in source using the following convention:</p>
<pre class="assembly"><code>mov byte al, [es:32]</code></pre>
<p>This will move the byte located in <code>es:32</code> into <code>al</code>.</p>
</div>
<div class="sidenotes">
<p><sup>1</sup> Note that <code>ORG</code> or origin is also factored in.</p>
</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
<div class="tufte-section">
<div class="main-text">

</div>
<div class="sidenotes">

</div>
</div>
</body>
</html>
