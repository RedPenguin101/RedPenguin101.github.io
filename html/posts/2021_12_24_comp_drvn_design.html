<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Simple Component Driven ClojureScript</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Simple Component Driven ClojureScript</h1>
</header>
<p><a href="https://davidvujic.blogspot.com/2021/12/simple-component-driven-clojurescript.html?utm_source=pocket_mylist">Link</a></p>
<ul>
<li>Grouping relevant code into <em>components</em>, components into features, features into views, views into an app.</li>
<li>Lego like.</li>
<li>To do this effectively, we would like something to host and render our components, segregated from any specific application / context. <a href="https://storybook.js.org/">Storybook</a> does that, but you can do it without a tool.</li>
<li>Quick and dirty: set up a new build alias ‘story’ with browser target, but on a separate port. Then an <code>app.story</code> namespace where you can quickly chuck any component you want to render in isolation in that target. Have one browser rendering your full app, and one just rendering the component.</li>
</ul>
<p>When you want to get more complex, use storybook. Video on how <a href="https://youtu.be/beMFh99EE7w">here</a></p>
</body>
</html>
