<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Clojure for Factorio calculator</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Clojure for Factorio calculator</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#factorio">Factorio</a></li>
<li><a href="#a-program-for-calculating-optimal-machines">A program for calculating optimal machines</a></li>
<li><a href="#clojure-and-why-it-is-well-suited-to-this-problem">Clojure (and why it is well suited to this problem)</a></li>
<li><a href="#writing-the-program">Writing the program</a><ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#defining-the-api-and-underlying-structures">Defining the API and underlying structures</a></li>
<li><a href="#rdd-and-tdd">RDD and TDD</a></li>
</ul></li>
</ul>
</nav>
<h1 id="factorio">Factorio</h1>
<p>I’ve been playing <a href="https://www.factorio.com/">Factorio</a> recently. It’s a game about building an optimal, automated factory. It’s very good, I’d recommend it.</p>
<p>The premise is that you start with raw materials, like iron, copper, coal, and use those to build things like iron gears and copper wires, which themselves can be assembled into power lines, smelting machines, and many other things. While your player-character can build most of these things, the goal is to make production lines of assemblers and <em>automate</em> the build process. In other words, build a factory. Over the course of the game the recipes get ever more elaborate, with more types of materials and more of those materials required to build things, necessitating optimization of your factory.</p>
<h1 id="a-program-for-calculating-optimal-machines">A program for calculating optimal machines</h1>
<p>A key part of the Factorio challenge is building effective assembly lines. For example, to build ‘Blue science packs’ (a mid-game material required for research), you need to feed an assembler with 3 red circuits, 2 engines, and 1 unit of sulphur. A red circuit needs an assembler fed with 4 copper wires, 2 green circuits, and 2 plastic bars, etc. In total, to produce an adequate number of blue science packs, you need around 48 assemblers in total.</p>
<p>But how to know how many of each assembler you need? And how much raw material you will need to feed the assembly line? This is a calculation based on the properties of each factory, and we can solve it with a program.</p>
<p>Initially I used a Google Sheets spreadsheet to do these calculations, but it quickly got tedious, and was very error prone. So I decided to write a small computer program to do it for me. My program language of choice is Clojure, and the language seems very appropriate for this use case. So that’s what I used.</p>
<h1 id="clojure-and-why-it-is-well-suited-to-this-problem">Clojure (and why it is well suited to this problem)</h1>
<p>Clojure is a programming language that was created in 2007 by Rich Hickey. Rich’s motivation for creating the language was that he had been programming professionally for twenty years in traditional, mostly statically typed object oriented languages, and was convinced that they were not well suited for the projects he was working on. He goes into much more detail about that in <a href="https://www.youtube.com/watch?v=2V1FtfBDsLU">this talk</a>.</p>
<p>Clojure is both a LISP and a functional programming language. That means:</p>
<ul>
<li>There are a lot of parentheses</li>
<li>There is no mutable state</li>
<li>The idioms of programming from ‘imperative’ languages (nearly all mainstream languages) are largely not applicable here, and often will be anti-patterns. For example, explicit loops are used very rarely, in favor of higher-order functions (like map and reduce) and recursion</li>
<li>There are no classes, or types, in the traditional sense. All collections of data are handled by generic hashmaps, sets and sequences. It’s like programming in Python when you can only use dictionaries and lists, never defining a class.</li>
<li>The standard library, while excellent, is both very large, and very necessary to know well to program effectively. It will take a long time to learn how to use it well.</li>
</ul>
<p>All of this can make it very difficult for newcomers from traditional languages to get comfortable with Clojure. Moving from Java to C#, or Python to Ruby, can be done quite quickly because all these languages share a common paradigm. That’s not the case with Clojure.</p>
<p>I would compare moving from an imperative language to Clojure as similar to moving from a garbage collected language to one with manual memory management: You have to learn a whole new way of thinking, and it can be very frustrating.</p>
<p>So it can take a long time, several months, to get to the point where you are even basically competent with the language.</p>
<p>However there are some large upsides that I would consider worth the cost of entry:</p>
<ul>
<li>The development experience (Primarily the “REPL”) is revelatory. Once you are used to it, it will be very hard to lose it when you go back to another language</li>
<li>Using generic collections in place of classes, when you ‘get’ it, is wonderful</li>
<li>When you have enough experience with the standard library you can play the language like a piano.</li>
<li>Programming without mutable state, while it has downsides, is overall much better.</li>
<li>The nature of the language can produce very concise, some would say very beautiful, code</li>
</ul>
<p>So, aside from the fact I like the language, what makes it suitable for this use case?</p>
<p>While Clojure can be used in a broad way (anything you can do with Java you can do with Clojure, and anything you can do with JavaScript, including React Web Apps you can do with Clojure), for this use case I don’t want a big, traditional application, or even a web app. I just want something I can run quickly on my second monitor to see what assemblers I need to have to build a specified material.</p>
<p>The normal go-to solutions for this would probably be a command line application, or some kind of executable notebook like Jupyter. What Clojure can offer here is something that is sort of in-between these two: a truly integrated development experience.</p>
<p>In short, you write your program in your IDE of choice, and then <em>you execute parts of it directly from the IDE</em>. There is no additional infrastructure needed, you write and execute in the same place. This leads to a very tight feedback loop: you execute parts of the program, see what you need to change, change the code, then re-execute, all in the same place. In that sense it’s similar to a Jupyter Notebook, but Clojure does it better.</p>
<p>For the rest of this post I’m going to describe, with code, how I wrote the program. It’s not a tutorial, and won’t explain much about the language, but it should be complete enough to follow along. Also, I’m not claiming it’s a <em>good</em> program, but it works well enough.</p>
<p>If you do want to follow along, you’ll need to install the JDK (version 11 or up is recommended), and install Clojure itself (from <a href="https://www.clojure.org/guides/getting_started">here</a>) - Linux and Mac are much better experiences than Windows, so if you’re on Windows I’d recommend using WSL.</p>
<p>Install VS Code and the <a href="https://calva.io/">Calva</a> extension, and you should be good to go.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<h1 id="writing-the-program">Writing the program</h1>
<h2 id="setup">Setup</h2>
<p>First I create a simple directory structure, and a file <code>deps.edn</code> in the root. In that file I put <code>{}</code> and nothing else. This is basically the configuration file for the program, but we can leave it empty (except for the <code>{}</code>) for now, it’ll work fine.</p>
<p>Next I open a source file <code>src/factorio/main.clj</code>. At the top of the file I write the namespace <code>(ns factorio.main)</code></p>
<p>Next I start the REPL<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> using the REPL button at the bottom of the window (this is what the Calva extension does). An <code>output.calva-repl</code> window will open, but I close it since I don’t need it.</p>
<p>I check the REPL is working by typing <code>(+ 1 1)</code> in the src window and, with the cursor in that form, hitting <code>Alt+Enter</code>. If all goes well you should see <code>(+ 1 1) =&gt; 2</code>. This is what the REPL does: it allows you to execute bits of code in the IDE and see the result of that execution next to the bit of code.</p>
<p>With the setup done, we will start to write the program.</p>
<h2 id="defining-the-api-and-underlying-structures">Defining the API and underlying structures</h2>
<p>What I want is a program that, when I say “I want to produce 2 Blue Science Packs per second”, it will tell me how many assemblers of each type I need, plus how much raw material feeding into the assembly line per second. Something like <code>(assembly-line output pps inputs assembler-recipes)</code>, where <code>assembly-line</code> is the function, output is Blue Science, <code>pps</code> is desired parts per second, and inputs is the available inputs. I stub that out.</p>
<p>Inputs is just a collection of named materials. I use a set (<code>#{}</code>) to represent them. The contents of the set, prefixed with <code>:</code> are ‘keywords’. Just think of them as little strings.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb1-1" title="1">(<span class="bu">def</span><span class="fu"> inputs </span>#{<span class="at">:stone</span> <span class="at">:stone-brick</span> <span class="at">:water</span> <span class="at">:iron-plate</span> <span class="at">:copper-plate</span> <span class="at">:steel-plate</span> <span class="at">:petroleum</span>})</a></code></pre></div>
<p>What about assembler recipes? How to represent those? Each recipe has an output (what it produces), a time to produce, and a list of inputs.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<p>In another language, this is where I might start defining classes. Here, I’m just going to use a dictionary/hashmap, usually just called a ‘map’ in Clojure.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb2-1" title="1">(<span class="bu">def</span><span class="fu"> assembler-recipes</span></a>
<a class="sourceLine" id="cb2-2" title="2">{<span class="at">:red-science-factory</span> {<span class="at">:output</span> <span class="at">:red-science</span></a>
<a class="sourceLine" id="cb2-3" title="3">                       <span class="at">:time</span> <span class="dv">53</span></a>
<a class="sourceLine" id="cb2-4" title="4">                       <span class="at">:inputs</span> {<span class="at">:copper-plate</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-5" title="5">                                <span class="at">:iron-gear</span> <span class="dv">1</span>}}</a>
<a class="sourceLine" id="cb2-6" title="6"> <span class="at">:green-science-factory</span> {<span class="at">:output</span> <span class="at">:green-science</span></a>
<a class="sourceLine" id="cb2-7" title="7">                         <span class="at">:time</span> <span class="dv">6</span></a>
<a class="sourceLine" id="cb2-8" title="8">                         <span class="at">:inputs</span> {<span class="at">:yellow-belt</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-9" title="9">                                  <span class="at">:yellow-inserter</span> <span class="dv">1</span>}})</a></code></pre></div>
<p>After I write both of these I execute them using <code>Alt+Enter</code>, which will save them into memory.</p>
<p>Next I start to fill out the <code>assembly-line</code> function. The first thing I want to do is figure out which recipes produce which parts. I can do that by referring back to my <code>assembler-recipes</code> map.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb3-1" title="1">(<span class="bu">defn</span><span class="fu"> producers </span>[recipes]</a>
<a class="sourceLine" id="cb3-2" title="2">  (<span class="kw">into</span> {} (<span class="kw">for</span> [[factory {<span class="at">:keys</span> [output]}] recipes] </a>
<a class="sourceLine" id="cb3-3" title="3">    [output factory])))</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">(producers assembler-recipes)</a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">;; =&gt; {:copper-cable :copper-cable-factory,</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">;;     :iron-gear    :iron-gear-factory,</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">;;     :factory1     :factory1-factory,</span></a></code></pre></div>
<p>The <code>producers</code> function has some funky list comprehension and map-destructuring syntax which, while very clear if you know the language, might not be so obvious if you don’t know the language well. All this function is doing is taking the <code>assembler-recipes</code>, taking each recipe, taking each output, and inverting the map. The equivalent in Python might be something like <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> producers(recipes_dict):</a>
<a class="sourceLine" id="cb4-2" title="2">  retval <span class="op">=</span> Dict()</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="cf">for</span> (factory, recipe) <span class="kw">in</span> recipes.items():</a>
<a class="sourceLine" id="cb4-5" title="5">    retval[recipe[<span class="st">&#39;output&#39;</span>]] <span class="op">=</span> factory</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="cf">return</span> retval</a></code></pre></div>
<h2 id="rdd-and-tdd">RDD and TDD</h2>
<p>The main thing I want to point out is not the function itself, but how I wrote it. I started out with a stub, and the <code>(producers assembly-lines)</code>, and every time I added something to the function, I executed <code>(producers assembly-lines)</code> with <code>Alt+Enter</code>, which let me see what the output was. In this way I was able to quickly build up the function from very small changes, seeing the results of my changes at each point.</p>
<p>This is <em>sort of</em> like traditional Test Driven Development. In TDD you write a test (a specification of input and output), write the code that produces the outcome you want, and run the test to make sure the input matches the output. If it does, you write another test. The goal is to create a very fast feedback loop between changing code, and checking that the changed code does what you want.</p>
<p>In both the TDD and Clojure cases, the pattern is the same:</p>
<ul>
<li>You decide what the inputs and outputs of the function should be</li>
<li>You write the code that does it</li>
<li>You try it out and see if it matches. If it does you start the process again.</li>
</ul>
<p>The main difference between TDD and the Clojure pattern (which is so ubiquitous it has a name, “REPL Driven Development”), is that the Clojure version is <em>much</em> more fluid: you’re not jumping between code and tests, you’re not writing a new test every time you want to write some code.</p>
<p>Two of the main criticisms of TDD are, first, that it can produce a <em>lot</em> of unnecessary tests, to the extent that many people recommend deleting <em>most</em> of the tests you write in this way when you’ve finished developing, and second that it is very boring (or, more charitably, requires a lot of discipline). The Clojure version does away with the first by not having these ‘intermediate’ tests - you’re just running the code and seeing that it does what you want - and manages the second by keeping the feedback loop much tighter.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>The other thing to note is that the last three lines of the Clojure snippet (with the semi-colons, which are comments) are the result of executing the <code>(producers assembler-recipes)</code>, but instead of <code>Alt+Enter</code> I pressed <code>Ctrl+Alt+C &amp; C</code>. This executed the code and put the result in a comment, so you can easily refer back to it if you forget exactly what the function does and what it produces.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Most IDEs work well with Clojure, but VS Code in my view has the easiest path to being productive. Emacs is widely used, but has a learning curve steeper than Clojure itself.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>REPL stands for “read, evaluate, print, loop”<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>there are a couple of complications here, like a few recipes produce multiple outputs, and some produce more than 1 unit at each run, but we can deal with them later.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>might not be technically correct, but should be clear enough.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>Incidentally, if you do want to do traditional TDD in Clojure it works very well. But RDD is just better.<a href="#fnref5" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
