<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Zach Tellman: Designing a Framework for Conversational Interfaces</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Zach Tellman: Designing a Framework for Conversational Interfaces</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#semantic-machines-solution">Semantic Machines solution</a><ul>
<li><a href="#plans">Plans</a></li>
<li><a href="#constraints">Constraints</a></li>
<li><a href="#revision">Revision</a></li>
</ul></li>
</ul>
</nav>
<p><a href="https://www.microsoft.com/en-us/research/group/msai/articles/designing-a-framework-for-conversational-interfaces">Link</a></p>
<blockquote>
<p>“Early AI researchers envisioned a world where knowledge had a singular representation and a singular repository. Instead, we live in a world where data, and the ability to interpret it, is fragmented and diffuse. As a result, our constraint solver must be unusually extensible, allowing developers to compose it with their own systems and domain expertise.”</p>
</blockquote>
<h1 id="intro">Intro</h1>
<p>Zach and Semantic Machines (SM) are working on the conversational interface for Outlook Mobile.</p>
<p>The value proposition is that users can ask for what they want in a natural way, replacing nested menus or memorized commands, which have high cognitive load and cost to learn.</p>
<p>Modern conversational systems usually have a ‘slot and intents’ model <strong>S&amp;I</strong>: the user <em>utterance</em> is matched to an <em>intent</em> template Information is then extracted from the appropriate <em>slots</em>:</p>
<blockquote>
<p>“Order me a medium pizza with pepperoni and mushrooms”</p>
</blockquote>
<p>Would be matched to a pizza ordering intent. The information <code>{:size "medium", :toppings ["pepperoni", "mushrooms"]}</code> could be easily extracted. The function <code>order_pizza("medium", ["pepperoni", "mushrooms"])</code> can then be called. Linguistic and Business logic are well separated.</p>
<p>Consider a command:</p>
<blockquote>
<p>“Find a block which is taller than the one you are holding and put it into the box.”</p>
</blockquote>
<p>This is more difficult to model, and to separate linguistic and business logic. Natural language is <em>compositional</em>, and S&amp;I frameworks are not. The above demands a set ideas that can be combined with little restriction (“find a block,” “taller than,” “held block,”). S&amp;I doesn’t allow for this flexibility.</p>
<h1 id="semantic-machines-solution">Semantic Machines solution</h1>
<h2 id="plans">Plans</h2>
<p>Utterances are translated into small programs call <strong>plans</strong> using a <em>transformer-based encoder-decoder neural network</em>.</p>
<blockquote>
<p>“Find a block which is taller than the one you are holding and put it into the box.”</p>
</blockquote>
<p>Becomes:</p>
<pre><code>find_block((b: Block) =&gt; taller_than(b, held_block()))
put_in_box(the[Block]())</code></pre>
<p>The purpose is <em>only translation</em>, not <em>interpretation</em>. There is a level of indirection here, since the first line might be more naturally (for a programmer) be expressed like</p>
<pre><code>find_block((b: Block) =&gt; b.height &gt; held_block().height)</code></pre>
<p>We don’t want to assume. Implementations of things can get pretty nuanced when a person is involved.</p>
<p>The utterance has a mix of context-independent and context-dependent language (definite articles). Were you to take only the second statement: <em>“Put <strong>it</strong> into the box”</em>, you would not know to which thing “it” refers, until you include the surrounding context: “Find a block…” resolves “it”, and so you can interpret the statement by looking for things that apply to a box.</p>
<p>SM has a referential resolution system which tracks the history of context. So calls to <code>the</code> will query a graph of every plan in the conversation to figure out what it resolves to.</p>
<h2 id="constraints">Constraints</h2>
<p>An <strong>intensional description</strong> (as opposed to extensional) is one that provides criteria for finding the entity e.g. “A block that is taller than the one you are holding”. In reality, all descriptions are intensional, since there is no way to uniquely specify an entity: the closest we get is a <em>name</em>, but they are ambiguous enough that we need to search our context to resolve the entity.</p>
<p>How to resolve this? A simplistic way would be as a predicate function: <code>the[Person](p =&gt; p.name ~= "Alice")</code> and map over ‘people’. But the ‘Person’ dataset is likely to be remote, large, and limited (for privacy) in what it exposes. We need to <em>query</em> for it. Unfortunately, that pushes the query implementation logic (of, say <em>similarity</em>) to the API, which probably won’t suit us. We need to pass our <em>constraints</em> to the query, as well as passing them the tools for interpreting those constraints, usually called <em>controllers</em>.</p>
<h2 id="revision">Revision</h2>
<p>Language is ambiguous. “I’m heading to the bank” can have several meanings. <em>Pragmatics</em> is the study of how context confers meaning.</p>
<p>SM provide a <code>revise</code> operator which, given two constraints <code>a</code> and <code>b</code>, will merge those into a single constraint with the parts of <code>a</code> that keep <code>b</code> from being meaningful removed.</p>
<p>For example, if you end with two constraints: one which looks for a meeting in the future, and one that looks for a meeting in the past, if you combine them you’ll end up with a self-contradicting constraint.</p>
<pre><code>revise(
  e =&gt; e.start &gt; now() &amp;&amp; e.attendees.contains(me()), 
  e =&gt; e.start.date == yesterday(),
)

e =&gt; e.start.date == yesterday() &amp;&amp; e.attendees.contains(me())</code></pre>
<p>Contradictions don’t have to be as binary as this. Consider the constraints <code>e.start &gt; now()</code> and <code>e.start &gt; beginning_of_year()</code>. The first does not <em>contradict</em> the second in all cases, but if the <code>&gt; now()</code> is kept we will be excluding results that the user wants to see. So the <code>now()</code> must be recognised and discarded.</p>
</body>
</html>
