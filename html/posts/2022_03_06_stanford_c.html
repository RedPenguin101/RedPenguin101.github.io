<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Stanford on C</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Stanford on C</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#essential-c">101: Essential C</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#basic-types-and-operators">1: Basic types and operators</a><ul>
<li><a href="#integer-types">Integer types</a></li>
<li><a href="#floats">Floats</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#casting">Casting</a></li>
<li><a href="#operators">Operators</a></li>
</ul></li>
<li><a href="#control">2: Control</a></li>
<li><a href="#data-types">3: Data types</a><ul>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#typedef">TypeDef</a></li>
</ul></li>
<li><a href="#functions">4: Functions</a></li>
<li><a href="#other-stuff">5: Other stuff</a></li>
<li><a href="#advanced-arrays-and-pointers">6: Advanced arrays and pointers</a><ul>
<li><a href="#heap">Heap</a></li>
</ul></li>
<li><a href="#libraries">7: Libraries</a><ul>
<li><a href="#stdio">stdio</a></li>
<li><a href="#ctype">ctype</a></li>
<li><a href="#string">string</a></li>
<li><a href="#stdlib">stdlib</a></li>
</ul></li>
</ul></li>
<li><a href="#pointers-and-memory">102: Pointers and Memory</a><ul>
<li><a href="#local-memory">2: Local memory</a></li>
</ul></li>
</ul>
</nav>
<ul>
<li><a href="http://cslibrary.stanford.edu/101/EssentialC.pdf">101</a></li>
<li><a href="http://cslibrary.stanford.edu/102/PointersAndMemory.pdf">102</a></li>
<li><a href="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf">103</a></li>
</ul>
<h1 id="essential-c">101: Essential C</h1>
<h2 id="introduction">Introduction</h2>
<ul>
<li>C is not forgiving. It will not help you</li>
<li>It expect that you know how it works</li>
<li>It is “simple” in that is has only a few components</li>
</ul>
<h2 id="basic-types-and-operators">1: Basic types and operators</h2>
<h3 id="integer-types">Integer types</h3>
<ul>
<li><code>char</code>: ASCII character, at least 8 bits. -128..127, or 0..255</li>
<li><code>short</code>: at least 16 bits, -32768..32767</li>
<li><code>int</code>: at least 16 bits, usually 32.</li>
<li><code>long</code>: at least 32 bits, ~ -2bn..2bn</li>
<li>Generally, avoid unsigned, causes more problems than it solves</li>
<li>pointers are sort of like an <code>unsigned long</code>, where the number is the (4 byte) memory address.</li>
<li>C defines <em>minimum</em> sizes for integers, not exact sizes. This can cause compatibility issues. Consider this if you’re writing a program that will run on many manchines</li>
<li>Chars are written in single quotes. <code>'A'</code> etc. or special chars like <code>\n</code>, <code>\t</code></li>
<li>Behind the scenes, just an 8bit integer value. ‘A’ is 65.</li>
<li>A <code>long</code> constant can be designated like <code>24L</code></li>
<li>A constant can be written in hex with <code>0x10</code> (16), or Octal with <code>012</code> (leading zero) (10)</li>
<li>C is weakly typed and will promote as required. <code>'b'+5</code> is fine. The char will be promoted to an int.</li>
<li>C will also truncate e.g. from <code>char</code> to <code>int</code>, but not automatically:</li>
</ul>
<pre><code>double pi;
int i;
pi = 3.14159;
i = pi; // i is now 3</code></pre>
<ul>
<li>There is no boolean, use int. 0 is false, non-zero is true.</li>
</ul>
<h3 id="floats">Floats</h3>
<ul>
<li><code>float</code>: single precision (32 bits, about 6 digits)</li>
<li><code>double</code>: double precision (64 bits, about 15 digits)</li>
<li>constants (<code>x.y</code>) are doubles, unless suffixed with <code>f</code>.</li>
</ul>
<h3 id="comments">Comments</h3>
<ul>
<li><code>/* .. comments ..*/</code> can be multiline</li>
<li><code>//</code> (line comment) are technically from C++, but are usually supported.</li>
</ul>
<h3 id="variables">Variables</h3>
<ul>
<li>Declare with <code>int num;</code></li>
<li>Assign value with <code>num = 42</code></li>
<li>A variable corresponds to an area or ‘box’ in memory, which can contain a value of the specified type.</li>
<li>The memory location is not initialized, it’ll contain some random thing until you set it.</li>
<li>Declare multiple with <code>int a, b, c;</code></li>
<li>assignment is also an expression returning the assigned value: <code>y = (x = 2 * x)</code> is valid. Don’t do this.</li>
</ul>
<h3 id="casting">Casting</h3>
<ul>
<li>cast like <code>score = ((double)score/20) * 100</code>. Casts <code>int score</code> to a double before doing the division. Though <code>(score/20.0)</code> will autocast <code>score</code> to a double.</li>
</ul>
<h3 id="operators">Operators</h3>
<ul>
<li><code>+-/*</code>.</li>
<li><code>%</code> mod</li>
<li>Unary increments: <code>var++</code>, <code>var--</code> unary operators</li>
<li>Also <code>++var</code>, <code>--var</code>. These return expressions, so can be used in, for example, loop conditions. Don’t though.</li>
<li>Relationals: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code> etc.</li>
<li>Logicals: <code>!</code>, <code>&amp;&amp;</code>, <code>||</code>. Evaluate left to right, and short circuit.</li>
<li>Bitwise: <code>~</code> (bitwise negate), <code>&amp;</code>, <code>|</code>, <code>^</code> (XOR),</li>
<li><code>&gt;&gt;</code> and <code>&lt;&lt;</code> are shift left/right. Equivalent to dividing by power 2, multiplying by power 2.</li>
</ul>
<h2 id="control">2: Control</h2>
<ul>
<li><code>{}</code> are for grouping.</li>
<li><code>if (&lt;expression) &lt;statment&gt;</code></li>
<li><code>if (&lt;expression) {&lt;statments&gt;}</code></li>
<li><code>if (&lt;expression) {&lt;statment&gt;} else {&lt;statement&gt;}</code></li>
<li>Ternary: <code>&lt;expr1&gt; ? &lt;expr2&gt; : &lt;expr3&gt;</code></li>
<li><code>min = (x &lt; y) ? x : y;</code></li>
<li>switch (awful). Fall through. Breaks necessary to exit.</li>
<li><code>while(&lt;expression&gt;){&lt;statement&gt;}</code></li>
<li><code>do {&lt;statement&gt;} while (&lt;expression&gt;)</code>. Test condition at end. Don’t use it.</li>
<li><code>for (&lt;init&gt;; &lt;cont&gt;; &lt;action&gt;){&lt;statment&gt;}</code></li>
<li><code>for (i=0; i&lt;10; i++){&lt;statment&gt;}</code></li>
<li><code>break</code> will move control in loop to outer block. Use sparingly. Doesn’t work for <code>if</code>s.</li>
<li><code>continue</code> will skip to the bottom of the loop. Use <em>even more</em> sparingly, usually prefer an if.</li>
</ul>
<h2 id="data-types">3: Data types</h2>
<ul>
<li>Arrays and Records (structures)</li>
<li>Define with <code>struct fraction {int numerator; int denominator;};</code>. Remember the semicolon at the bottom.</li>
<li>Declare with <code>struct fraction f1</code></li>
<li>Access with .: <code>f1.numerator</code></li>
<li>Assignment copies (i.e. they don’t point to same memory loc): <code>f1=f2</code></li>
<li><code>==</code> doesn’t work on structs.</li>
<li><code>int scores[100]</code> declares a 100 length array of integers</li>
<li><code>scores[0]=13;</code> sets the first element</li>
<li><code>scores[99]=42;</code> sets the last element</li>
<li>The name of an array refers to the whole array. Technically, it is a pointer to the memory address of the first element.</li>
<li><code>int board[10][10]</code> is a 2d array. This is just sugar, since in memory it’s just a contiguous block of 100 integers. <code>board[1][8]</code> is next to <code>board[1][9]</code>.</li>
<li><code>struct fraction numbers[1000]</code> declares an array of structs.</li>
</ul>
<h3 id="pointers">Pointers</h3>
<ul>
<li>A pointer is a value which contains a memory location.</li>
<li><code>*</code> is used to indicate a pointer. e.g. a <code>char*</code> is a pointer to a char. They are declared like any other variable <code>int* intPtr</code>.</li>
<li>In an expression, use <code>*x</code> (where <code>x</code> is a pointer) to dereference.</li>
<li><code>-&gt;</code> is sugar for deref and access. <code>f1-&gt;numerator</code> (where <code>f1</code> is a pointer).</li>
<li><code>&amp;</code> computes a pointer to the argument to its right. Use when you have some memory and what a pointer to that memory</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dt">int</span>* p; <span class="co">// a pointer to an integer</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="dt">int</span> i; </a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">  i = <span class="dv">10</span>;</a>
<a class="sourceLine" id="cb2-6" title="6">  p = &amp;i; <span class="co">// set p to point to i</span></a>
<a class="sourceLine" id="cb2-7" title="7">  *p = <span class="dv">13</span>; <span class="co">// set the thing p points to (i) to 13 </span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="co">// i IS 13. *p IS i. So *p IS 13.</span></a>
<a class="sourceLine" id="cb2-9" title="9">}</a></code></pre></div>
<ul>
<li>A pointer assigned <code>0</code> means it doesn’t have a pointee (aka null pointer)</li>
<li>(<code>NULL</code> is actually just a constant with value 0)</li>
<li>Don’t try to dereference a null pointer.</li>
</ul>
<h3 id="strings">Strings</h3>
<ul>
<li>Minimal support</li>
<li>Just arrays of char with a null (<code>\0</code>) terminator</li>
<li>assignment (<code>=</code>) doesn’t copy strings. use <code>strcpy</code>.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">char</span> string[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">int</span> len;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">strcpy(string, <span class="st">&quot;binky&quot;</span>);</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">// string = [b,i,n,k,y,\0,x,x,x,x,...]</span></a>
<a class="sourceLine" id="cb3-6" title="6">len = strlen(string);</a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">// len = 5</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb3-10" title="10"><span class="dt">char</span> temp;</a>
<a class="sourceLine" id="cb3-11" title="11"><span class="co">// string reversal.</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="cf">for</span> (i=<span class="dv">0</span>, j=len-<span class="dv">1</span>; i&lt;j; i++, j--) {</a>
<a class="sourceLine" id="cb3-13" title="13">  temp = string[i];</a>
<a class="sourceLine" id="cb3-14" title="14">  string[i] = string[j];</a>
<a class="sourceLine" id="cb3-15" title="15">  string[j] = temp;</a>
<a class="sourceLine" id="cb3-16" title="16">}</a></code></pre></div>
<ul>
<li><code>char string[1000]</code> is either wasteful or dangerous in many cases. Heap allocation of strings is usually preferable.</li>
<li>note that if <code>char string[10]</code>, the type of <code>string</code> is essentially a <code>char*</code>, since it’s a pointer to the memory location of the first char.</li>
</ul>
<h3 id="typedef">TypeDef</h3>
<ul>
<li>Defines a type</li>
<li><code>typedef struct fraction Fraction</code> to define the type</li>
<li><code>Fraction f1;</code> to declare.</li>
<li>really just an alias mechanism.</li>
</ul>
<h2 id="functions">4: Functions</h2>
<ul>
<li>Functions in a file are in a ‘namespace’</li>
<li>the special function <code>main</code> is called when program executes.</li>
<li>Convention is to start function with uppercase.</li>
<li><code>static int Twice(int num) { return(2 * num); }</code></li>
<li><code>static</code> means private to namespace</li>
<li><code>void</code> (return) type means “nothing”.</li>
<li>functions can accept a void, but generally we just write <code>int MyFunc()</code></li>
<li>functions are pass-by-value (i.e. copied)</li>
<li>Pass by reference is done with pointers</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> Swap(<span class="dt">int</span>* x, <span class="dt">int</span>* y) {</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="dt">int</span> temp;</a>
<a class="sourceLine" id="cb4-3" title="3">  temp = *x;</a>
<a class="sourceLine" id="cb4-4" title="4">  *x = *y;</a>
<a class="sourceLine" id="cb4-5" title="5">  *y = temp;</a>
<a class="sourceLine" id="cb4-6" title="6">}</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="dt">int</span> a = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb4-9" title="9"><span class="dt">int</span> b = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb4-10" title="10">Swap(&amp;a, &amp;b); <span class="co">// &amp; Computes pointers to a and b</span></a></code></pre></div>
<h2 id="other-stuff">5: Other stuff</h2>
<ul>
<li>A ‘prototype’ gives a signature but not an implementation.</li>
<li><code>int Twice(int num);</code> (note semicolon)</li>
<li>What the hell is it for?</li>
<li>The preprocessor does stuff before the main source code is passed to the compile. Most common are <code>#define</code> (set up symbolic replacements) and <code>#include "foo.h"</code> or <code>#include &lt;foo.h&gt;</code>.</li>
<li><code>foo.h</code> should contain prototypes for the ‘static’ functions in <code>foo.c</code> (which should have <code>#include "foo.h"</code></li>
<li>don’t <code>#include</code> h files in other h files. It can cause compile errors.</li>
<li>Some compilers allow you to do <code>#pragma once</code> which will avoid the issue</li>
<li>use <code>assert(...)</code> for safety. Some compiler settings will exclude these, since they’re for testing.</li>
</ul>
<h2 id="advanced-arrays-and-pointers">6: Advanced arrays and pointers</h2>
<ul>
<li>Since an array variable is just a pointer to a memory location where you’ve declared an array to start, you can play games with pointers. But be careful.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> intArray[<span class="dv">6</span>];</a>
<a class="sourceLine" id="cb5-2" title="2">intArray[<span class="dv">3</span>] = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb5-3" title="3">intArray <span class="co">// has type int*</span></a>
<a class="sourceLine" id="cb5-4" title="4">intArray + <span class="dv">3</span> <span class="co">// gives a pointer to the value at intArray[3]</span></a>
<a class="sourceLine" id="cb5-5" title="5">intArray[<span class="dv">3</span>] <span class="co">// and</span></a>
<a class="sourceLine" id="cb5-6" title="6">*(intArray + <span class="dv">3</span>) <span class="co">// are equivalent.</span></a></code></pre></div>
<ul>
<li>Though an array variable is a pointer, it is a <em>const</em> pointer, meaning you can’t reassign it.</li>
</ul>
<h3 id="heap">Heap</h3>
<ul>
<li>The functions are in <code>&lt;stdlib.h&gt;</code></li>
<li>As opposed to stack, heap can be dynamically allocated to at runtime.</li>
<li><code>void* malloc(size_t size)</code>: request a contiguous block of memory, of <code>size</code> (in bytes). A <code>size_t</code> is just an unsigned long. Returns a pointer to the block (or null). Since the return type is <code>void*</code>, you’ll probably need to cast the pointer.</li>
<li><code>void free(void* block)</code>: Takes a pointer created by malloc and returns it to the heap.</li>
<li><code>void* realloc(void* block, size_t size)</code>: For efficiency, you can reuse allocated blocks.</li>
<li>You can allocate arrays on the heap manually, and use them basically identically to stack arrays.</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">int</span> a[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="dt">int</span>* b;</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">// manually allocating an array on the heap.</span></a>
<a class="sourceLine" id="cb6-4" title="4">b = (<span class="dt">int</span>*) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">1000</span>);</a>
<a class="sourceLine" id="cb6-5" title="5">assert(b!=NULL); <span class="co">// check alloc succeeded.</span></a>
<a class="sourceLine" id="cb6-6" title="6">a[<span class="dv">123</span>] = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb6-7" title="7">b[<span class="dv">123</span>] = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb6-8" title="8">free(b);</a></code></pre></div>
<ul>
<li>The difference is, you can define the size of the heap array at runtime, and change its size at runtime with <code>realloc()</code></li>
<li>if you forget to allocate, forget to deallocate, or do either of those things wrong, the program will crash at runtime (and is a pig to debug).</li>
<li>heap arrays work well with strings because it allows runtime sizing, meaning you can size the array properly. No need to <code>char string[1000]</code></li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="dt">char</span>* MakeStringInHeap(<span class="dt">const</span> <span class="dt">char</span>* source) {</a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="dt">char</span>* newString;</a>
<a class="sourceLine" id="cb7-5" title="5">  newString = (<span class="dt">char</span>*) malloc(strlen(source)+<span class="dv">1</span>); <span class="co">// +1 for terminator</span></a>
<a class="sourceLine" id="cb7-6" title="6">  assert(newString != NULL);</a>
<a class="sourceLine" id="cb7-7" title="7">  strcpy(newString, source);</a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="cf">return</span>(newString);</a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="co">// Note caller takes ownership, is responsible for freeing memory.</span></a>
<a class="sourceLine" id="cb7-10" title="10">}</a></code></pre></div>
<h2 id="libraries">7: Libraries</h2>
<ul>
<li>stdio: file input/output</li>
<li>ctype: character tests</li>
<li>string: strings!</li>
<li>math: math functions</li>
<li>stdlib: utils, including heap and random numbers</li>
<li>assert: assert macro</li>
<li>stdarg: support for functions with variable numbers of arguments</li>
<li>time: date and time.</li>
<li>limits, float: constants with type range values.</li>
</ul>
<h3 id="stdio">stdio</h3>
<ul>
<li><code>FILE* fopen(const char* fname, const char* mode)</code>: mode is r,w,a. returns NULL on error.</li>
<li><code>int fclose(FILE* file)</code> Returns EOF on error.</li>
<li><code>int fgetc(FILE* in)</code> next character from file <em>but as an int</em>, since it might not be an <code>char</code></li>
<li><code>char* fgets(char* dest, int n, FILE* in)</code> read next line, at most n-1 chars, stops at (and includes) <code>\n</code>.</li>
<li><code>ing fputc(int ch, FILE* out);</code> write ch to file. Returns <code>ch</code> (EOF on error)</li>
<li><code>int printf(const char* format_string, ...)</code> <code>%d</code> = int, Ld=long int, s=string, f=double, c=char.</li>
<li><code>int scanf(const char* format, ...)</code> opposite of printf. Pattern matches the input against format string. Has variants <code>sscanf</code> (reads from a string) and <code>fscanf</code> which reads from a file.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">int</span> num;</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="dt">char</span> s1[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="dt">char</span> s2[<span class="dv">1000</span>];</a>
<a class="sourceLine" id="cb8-4" title="4">scanf(<span class="st">&quot;hello %d %s %s&quot;</span>, &amp;num, s1 s2);</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">// Be careful with pointers!</span></a></code></pre></div>
<h3 id="ctype">ctype</h3>
<ul>
<li>simple character tests/operations</li>
<li><code>isalpha</code>, islower, isupper, isspace (incl. tab, newline etc), isdigit</li>
<li>toupper/tolower</li>
</ul>
<h3 id="string">string</h3>
<ul>
<li>None of these manage your memory for you</li>
<li><code>strlen</code>, <code>strcpy</code> already seen</li>
<li><code>size_t strlcpy(char* dest, const char* source, size_t dest_size)</code> string copy which truncates at the destination size.</li>
<li><code>char* strcat(char* dest, const char* source)</code> appends from source to dest.</li>
<li><code>int strcmp(const char* a, const char* b)</code> compares strings and returns -1, 0 (equal), 1. REPEAT: ZERO (aka FALSE) MEANS EQUAL</li>
<li><code>char* strchr(const char* searchIn, char ch)</code> search for ch in searchIn, returns pointer to character or NULL</li>
<li><code>strstr</code> similar, searches for substring.</li>
</ul>
<h3 id="stdlib">stdlib</h3>
<ul>
<li><code>int rand()</code> random integer between 0 and (usually) 32767</li>
<li><code>void srand(unsigned int seed)</code> sets seed that <code>rand()</code> uses.</li>
<li><code>malloc</code>,<code>free</code>,<code>realloc</code> we’ve seen</li>
<li><code>exit(int status)</code>. 0 signals normal program termination</li>
<li><code>void* bsearch(const void* key, const void* base, size_t len, size_t elem_size, &lt;compare_function&gt;)</code> binary search array. compare function is <code>int compare(const void* a, const void* b)</code> and should return -1,0,1. Returns pointer to found element.</li>
<li><code>void qsort(void* base, size_t len, size_t elem_size, &lt;comp&gt;)</code> quicksort.</li>
</ul>
<h1 id="pointers-and-memory">102: Pointers and Memory</h1>
<ul>
<li>Why pointers? Allow different sections of code to share information, and enables linked data structures (linked lists, trees)</li>
<li>A pointer is a reference to another value.</li>
<li>Or, a variable with a value that is the memory location of another variable.</li>
<li>To get from a pointer to a pointee, <em>dereference</em>.</li>
<li>A NULL pointer is pointer that points to nothing (value of the pointer is 0 in C). Deref a null pointer is a runtime error.</li>
<li>assigning a pointer to another pointer makes them point at the same pointee. Two pointers that point to the same pointee are “sharing”. This is often the goal of using pointers.</li>
<li>Draw memory drawing to help think about your pointer code!</li>
<li>A pointer starts uninitialized (or “Bad”). Always assign a pointer as soon as you declare it.</li>
<li>The <em>pointee</em> of a pointer also needs to be initialized for it to work properly.</li>
<li><code>&amp;x</code> returns a pointer to x (or “computes a reference”).</li>
<li><code>*p</code> dereferences a pointer, and returns the value of the pointee.</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="dt">int</span> a = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">int</span> b = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="dt">int</span> c = <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="dt">int</span>* p;</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="dt">int</span>* q;</a>
<a class="sourceLine" id="cb9-6" title="6">p = &amp;a;</a>
<a class="sourceLine" id="cb9-7" title="7">q = &amp;b;</a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9">c = *p; <span class="co">// assign c the value of *p, which is the value of a, i.e. 1</span></a>
<a class="sourceLine" id="cb9-10" title="10">p = q; <span class="co">// assigning q to p means that p now points to b.</span></a>
<a class="sourceLine" id="cb9-11" title="11">*p = <span class="dv">13</span>; <span class="co">// assigns b (*p) as 13</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="co">// a[1]   |-p</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="co">// b[13] &lt;--q</span></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="co">// c[1]</span></a></code></pre></div>
<h2 id="local-memory">2: Local memory</h2>
</body>
</html>
