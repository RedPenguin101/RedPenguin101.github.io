<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8" />
  <meta content="pandoc" name="generator" />
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport" />
  <title>2022_12_31_bitemporality_adventures</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="../../css/style.css" rel="stylesheet" />
</head>
<body>
<h1 id="adventures-in-bitemporality">Adventures in Bitemporality</h1>
<p>Let’s say we’re a company that provides regular services to other
companies, and we periodically bill them for them. We have a system
which calculates the billable amounts. We a simple reference system to
track our customers. For now, the only attribute we care about is their
name. We also assign each company an internal ID. We set up our system
on 01-15 (MM-DD), and want to put a company in our database. One of our
clients is called ‘Old Name’. It was incorporated on 01-01 (note: we’re
not actually <em>tracking</em> incorporation dates). They want to change
their name to ‘New name’. They do it on 02-01, but we only find out
about it on on 02-15. So we have the following events:</p>
<ul>
<li>01-01: the company ‘Old Name’ is incorporated</li>
<li>01-15: we add the company into our reference system, with an entity
ID of 1</li>
<li>02-01: Old Name changes their name to New Name</li>
<li>02-15: we find out about it, and update our records accordingly</li>
</ul>
<p>Our first table, when we set it up on 01-15, might look like
this:</p>
<pre><code>id   name
1    Old Name</code></pre>
<p>Then when we find out they’ve changed their name on 02-15, we update
the table (note the ID remains the same, because it’s the same company,
just with a different name):</p>
<pre><code>id   name
1    New Name</code></pre>
<p>Even on the surface level there are problems with this: Your system
now doesn’t ‘remember’ that the company with ID 1 used to be called ‘Old
Name’. If you get correspondence which erroneously refers to ‘Old Name’.
Your system won’t be able to help you out, because it doesn’t
remember.</p>
<p>Another scenario: say it’s currently 2-20. We want to issue an
invoice to the company, but the date of the invoice is 1-30 (the day
before the name change happened). For tax reasons, the invoice has to
reference the <em>old name</em> of the company. But a) your system
doesn’t even ‘remember’ the old name, and b) it couldn’t know that on
1-30 the name was ‘Old Name’.</p>
<h2 id="history-tables-and-timelines">History tables and Timelines</h2>
<p>What we need to maintain, instead of the current state of the entity,
is a the <strong>history</strong> of the entity: An unbroken series,
from ‘birth’ to ‘now’ of the attributes of an entity. A common way to
implement this is to replace our entity table with a ‘history’
table.</p>
<pre><code>COMPANY_TABLE
// state on 1-15
uid   eid  from  to    name
1     1    1-1   Null  Old Name

// state on 2-15
uid   eid  from  to    name
1     1    1-1   2-1   Old Name
2     1    2-1   Null  New Name</code></pre>
<p>Querying the table for the value as it was on 1-30
(<code>get company 1 1-30</code>) would look something like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a><span class="kw">select</span> <span class="op">*</span> <span class="kw">from</span> COMPANY_TABLE</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2" tabindex="-1"></a><span class="kw">where</span> eid <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3" tabindex="-1"></a>  <span class="kw">and</span> from_date <span class="op">&gt;</span> <span class="st">'01-30'</span></span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4" tabindex="-1"></a>  <span class="kw">and</span> (<span class="fu">to_date</span> <span class="kw">is</span> <span class="kw">null</span> <span class="kw">or</span> <span class="fu">to_date</span> <span class="op">&lt;=</span> <span class="st">'01-30'</span>)</span></code></pre></div>
<p>Changing the name to ‘New Name 2’ on 3-1 would look like this</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a><span class="kw">UPDATE</span> COMPANY_TABLE</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2" tabindex="-1"></a><span class="kw">SET</span> <span class="kw">to</span> <span class="op">=</span> <span class="st">'03-01'</span></span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3" tabindex="-1"></a><span class="kw">WHERE</span> <span class="kw">to</span> <span class="kw">is</span> <span class="kw">Null</span>;</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4" tabindex="-1"></a></span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> COMPANY_TABLE (eid, from_date, <span class="fu">to_date</span>)</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6" tabindex="-1"></a><span class="kw">VALUES</span> (<span class="dv">1</span>, <span class="st">'03-01'</span>, <span class="kw">Null</span>, <span class="st">'New Name 2'</span>);</span></code></pre></div>
<pre><code>COMPANY_TABLE
uid   eid  from_date  to_date    name
1     1    1-1        2-1        Old Name
2     1    2-1        3-1        New Name
3     1    3-1        Null       New Name 2</code></pre>
<p>We have had to change record 2 so the ‘to’ date is no longer
<code>Null</code>, and inserted the line with <code>uid=3</code>. To
generalise this, we can say that what we are creating for each ‘entity’
we care about is a <strong>timeline</strong>. A timeline-entry has the
structure <code>{FROM TO &lt;DATA&gt;}</code>. A timeline is a
collection of timeline-entries. <code>[{FROM TO &lt;DATA&gt;}]</code>.
There are certain invariants for a timeline:</p>
<ol type="1">
<li>the records in a timeline must be ‘contiguous’: there must be no
instant between the earliest <code>to</code> to the last
<code>from</code> which is not covered by a record.</li>
<li>the records must be non-overlapping: no instant can appear in
multiple records.</li>
<li>there must be at most one record with a NULL value for
<code>from</code></li>
<li>there must be at most one record with a NULL value to
<code>to</code></li>
</ol>
<h2 id="mutable-history">Mutable History</h2>
<p>The update model proposed above is compatible with immutable history.
The timeline can only move forward. The only acceptable update is to add
a new record onto the ‘end’ of the timeline, with a from date that is
<em>after</em> the from data of the previous end. For example, you could
not go back and insert a new name for the period <code>1-15</code> to
<code>2-15</code>.</p>
<p>But what if you do want to do that? There are certainly real-world
circumstances when you might need to do that. And there’s nothing
<em>stopping</em> you from doing it. But it is not trivial. Say you want
to insert into the timeline ‘Tween Name’, from 1-15 to 2-15:</p>
<pre><code>COMPANY_TABLE
uid   eid  from  to    name
1     1    1-1   1-15  Old Name
3     1    1-15  2-15  Tween Name
2     1    2-15  Null  New Name</code></pre>
<p>Notice that <em>both</em> existing records had to be modified: the
from and to date respectively. Also, the rid is now ‘out of order’ -
i.e. doesn’t follow the actual timeline. If we now insert another
record, ‘OW name’, valid from 1-14 to 2-16, we get this</p>
<pre><code>COMPANY_TABLE
uid   eid  from  to    name
1     1    1-1   1-14  Old Name
4     1    1-14  2-16  OW Name
2     1    2-16  Null  New Name</code></pre>
<p>Here, we not only modified records 1 and 2 <em>again</em>, but we
actually had to <em>delete</em> record 3. All this deleting and
updating-in-place should be starting to make your skin crawl. Writing
SQL to do this safely and reliably would not be a fun thing.</p>
<p>There is another problem here as well: The whole point of introducing
the history table was to <em>remember</em> the changes that were made,
and when. But now we want to <em>change the changes</em>, and we will
run into the same problem, a level down: Our system won’t remember that,
at some point, we <em>thought</em> the name of the company was ‘Tween
Name’ (even though it wasn’t).</p>
<p>Say you’re giving a presentation, and one of the slides (prepared a
while ago) shows the company ‘Tween Name’. Someone asks “who is that?”
You look in the system, and you see no reference to a company called
‘Tween Name’ - only Old Name, OW Name, and New Name. You have forgotten,
again.<sup class="fnref"><a href="#fn1" id="note1" title="Footnote 1">1</a></sup><span class="footnote" id="fn1">
<a class="fnref" href="#note1" title="Footnote 1 Reference">1</a> Of
course this example is quite unrealistic - the company name itself is
unlikely to change that frequently. But it could easily be the case for
other attributes. </span>
What we need is to record the history of the history.</p>

<h2 id="perception-and-bitemporality">Perception and Bitemporality</h2>
<p>Recall the timeline of events:</p>
<ul>
<li>01-01: the company ‘Old Name’ is incorporated</li>
<li>01-15: we add the company into our reference system, with an entity
ID of 1</li>
<li>02-01: Old Name changes their name to New Name</li>
<li>02-15: we find out about it, and update our records accordingly</li>
</ul>
<p>Up to now we’ve focused on when things ‘actually’ happened: on 1-1
the company was incorporated. On 2-1 the name was changed. What we have
ignored is that, in both cases, there is a gap between when the event
<em>actually happened</em> and when we <em>recorded it</em> in our
system. In the first case, we recorded the incorporation in our system
on 1-15, because that’s when they became a customer. In the second case,
we recorded the name change on 2-15 because that’s when we (and our
system) found out about it.</p>
<p>What we have, in effect, are <em>two separate timelines</em>: One
representing events that actually happened, and one which represents
when we recorded the effect of those events. Call these two timelines
the ‘actual timeline’, and the ‘knowledge timeline’. On a knowledge date
basis, you could represent the situation like this.</p>
<pre><code>COMPANY_TABLE_KNOWLEDGE
uid   eid  from  to    name
1     1    1-15  NULL  Old Name

COMPANY_TABLE_KNOWLEDGE
uid   eid  from  to    name
1     1    1-15  2-15  Old Name
2     1    2-15  Null  New Name</code></pre>
<h3 id="aside-what-is-actual-date-something-happened">Aside: What is
‘actual’ date something happened?</h3>
<p>I called the first timeline the ‘actual’ timeline. But there’s a bit
of subtly there. Consider these two timelines as being observations of
the same events from the perspective of two different participants. The
first (where the incorporation happened on 1-1 and the name change on
2-1) is the perception of the Company itself, and importantly also of
the ‘Company Registry’, who is legally responsible for maintaining
company records.</p>
<p>We can refer to these as being the ‘real world’ or ‘actual’ events,
but really this is just convention: The group who will agree on this
perception includes a recognised ‘authority’ (the Registry, having the
force of law), which gives the perception of the Registry a special
significance. Most neutral participants would concede that the
authority’s perception is the correct one. So we call this the ‘actual’
timeline, for convenience.</p>
<p>The second perception is your system’s. Your system observed the
events on 1-15 and 2-15 respectively. This viewpoint can often be
relevant to you, because ultimately your business is constantly making
decisions based on what your system knows at the time the decision is
made.</p>
<p>Ultimately there is nothing fundamentally special or privileged about
each of these viewpoints: they are just different perceptions of the
same events. We are lucky here that there <em>is</em> an authority whom
we can rely on to provide an authoritative ordering of events. Sometimes
we won’t be so lucky, and then things can get <em>hard</em>. We are also
simplifying things significantly, in that the two perspectives differ in
<em>when</em> things are changing, but do not have different perceptions
of <em>what</em> is happening, which would add another layer of
complexity.</p>
<h3 id="bitemporality-a-product-of-timelines">Bitemporality: a product
of timelines</h3>
<p>We saw that you can represent the two timelines (the actual and
knowledge) separately pretty easily. Things get more complicated when
you try to represent both at the same time - which is what we need to do
to solve the ‘history of the history’ problem posed above. This is the
primary problem of bitemporality that the rest of this post will
explore.</p>
<h2 id="a-matrix-representation-of-two-dimensional-time">A matrix
representation of two-dimensional time</h2>
<p>We have two timelines for our entities: 1. The ‘actual’ timeline (the
perception of the authority) 2. The ‘system’ timeline (the perception of
the system, really a proxy for the knowledge state of our business)</p>
<p>Things get more complicated when you try to record <em>both timelines
at once</em>, because they become a product. You can represent them as a
partially-filled matrix:</p>
<pre><code>AD=Actual Date
KD=Knowledge Date

X=not in system
O=old name
N=new name

AD→  12 1 1 2 2 2
      | | | | | |
KD    1 1 1 1 1 1
↓         5   4 5   
12-1  X
1-1   X X
1-15  X O O
2-1   X O O O
2-14  X O O O O
2-15  X O O N N N</code></pre>
<p>Thinking in multi-dimensional time is hard, so the semantics of this
can be tough to unpack. You can read the ‘rows’ as views of history. So
at <code>KD=2-14</code> we thought the company started existing on 1-1,
and from that point up to ‘now’ (2-14) the name was Old Name. But b
<code>KD=2-15</code> we learned that this was incorrect: the company did
start existing on 1-1, and was initially named ‘Old Name’, but from 2-1
it was called ‘New Name’.</p>
<p>You can read the columns as history of the our knowledge of the state
of the system at a particular date: What did we think the name was at
2-1? Reading down the relevant column, we first admit our ignorance:
when <code>KD=12-1 and 1-1 and 1-15</code>, the knowledge dates are
<em>before</em> the actual dates. Our system won’t guess the future, so
it just says “I don’t know”. At <code>KD=2-1</code> we thought the name
was ‘Old Name’. Note that this is <code>KD=AD</code>. This has special
significance, because it represents ‘what we knew at the time’. At
<code>KD=2-14</code> we still thought the name at <code>AD=2-1</code>
was ‘Old Name’. But at <code>KD=2-15</code> we finally realize that the
name at <code>AD=2-1</code> was actually ‘New Name’. So to coin a few
terms, we broadly have three ‘queries’ we can do over two time
dimensions:</p>
<ol type="1">
<li><strong>Co-temporal</strong>: AD=KD. “What we knew at the time”.
Based on what we knew at the time, the name of the company at 2-1 was
‘Old Name’</li>
<li><strong>Retrospective</strong>: AD&lt;KD. Hindsight. Based on what
we knew at 2-15, the name of the company at 2-1 was ‘New Name’</li>
<li><strong>Predictive</strong>: where AD&gt;KD. We are asking the
system what it’s knowledge state was <em>in the future</em>. Erroring
out here is a reasonable option, since you might not want your system to
try and ‘guess’ things. If you do, then this would be like: Based on
what we know at 2-15, the name of the company at 3-1 will be ‘New
Name’.</li>
</ol>
<p>Here are some more examples:</p>
<pre><code>    AD   KD
get 1-1 1-03 =&gt; nothing
get 1-1 1-16 =&gt; Old Name 

get 2-1 2-01 =&gt; Old Name          (A=K: cotemporal)
get 2-1 2-16 =&gt; New Name          (A&lt;K: retrospective)
get 2-1 1-16 =&gt; Old Name OR Error (A&gt;K: predictive)

get 3-1 2-15 =&gt; New Name OR Error</code></pre>
<h2 id="histories-of-histories-of-histories-no-thanks">Histories of
histories of histories? No thanks</h2>
<p>The problem we set out to solve with bitemporality was that we wanted
our timeline to be mutable, but also to be able to remember
<em>historical</em> changes we made to the actual timeline. We did that
by adding a second time dimension. Thinking in general terms, there is
no reason the second timeline can’t <em>also</em> be immutable. That is,
you could change when your system found out about things. However this
would bring the same problem of ‘forgetting’ changes, and the solution
would be the same: Add a <em>third</em> time dimension.</p>
<p>In practice, however, it’s hard to build a real use-case for
‘tritemporal’ time. If reasoning in bitemporal time is hard, reasoning
in three time dimensions doesn’t sound attractive. The reality is that,
if your two time dimensions can reasonably be called the ‘actual’ and
‘knowledge’ timelines, then you’re probably OK, because your knowledge
<em>can</em> be said to be immutable. You don’t suddenly discover that
you knew something a week ago. If you knew it a week ago, you knew it a
week ago.</p>
<p>So while it’s not absurd to think about higher dimensions of time, we
will constrain ourselves to two dimensions.</p>
<h2 id="alternative-to-matrix-representation-timeline-of-timelines">Alternative
to matrix representation: Timeline of Timelines</h2>
<p>Matrix representation has the benefits that it doesn’t privilege one
timeline over another: you can easily read it either way. It’s also
completely immutable: you don’t lose information, and can fully recreate
a previous state from the current state.</p>
<p>The downsides are that it can be tough to understand, and that it’s
really hard to represent as a data structure. A matrix that is growing
in both dimensions all the time isn’t easy to model either in structures
(i.e. nested name-values) or tables.</p>
<p>We’ve already seen the timelines structure:
<code>TIMELINE = [{FROM TO &lt;DATA&gt;}]</code>. There’s no reason this
can’t be extended to a timeline of timelines:
<code>TOT = [{FROM TO &lt;TIMELINE&gt;}]</code>. The only real
requirement here is that you have to <em>order</em> the dimensions: Do
you want a KD-Timeline of AD-Timelines, or an AD-Timeline of
KD-Timelines? This impacts access patterns and such. In most cases, the
answer is pretty simple: you want a KD-timeline of AD-Timelines. You
want to have <em>immutable</em> timeline on the ‘outside’, and the
mutable on the inside. A couple of representations:</p>
<pre><code>k-from  k-to
1-15    2-15
  Name       a-from a-to
  Old Name   1-1    Null

K-from  k-to
2-15    Null
  Name       a-from a-to
  Old Name   1-1    2-1
  New Name   2-1    Null</code></pre>
<pre><code>EID=1
[{1-15 2-15 [{1-1 Null Old-Name}]},
 {2-15 Null [{1-1 2-1  Old-Name}, 
             {2-1 Null New-Name}]}]</code></pre>
<h3 id="timeline-of-timelines-in-code">Timeline of timelines in
code</h3>
<p>The datastructure for timelines in clojure are basically as
above:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb14-1"><a aria-hidden="true" href="#cb14-1" tabindex="-1"></a><span class="co">;; timeline</span></span>
<span id="cb14-2"><a aria-hidden="true" href="#cb14-2" tabindex="-1"></a>[{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>} </span>
<span id="cb14-3"><a aria-hidden="true" href="#cb14-3" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>,     <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]</span>
<span id="cb14-4"><a aria-hidden="true" href="#cb14-4" tabindex="-1"></a> </span>
<span id="cb14-5"><a aria-hidden="true" href="#cb14-5" tabindex="-1"></a><span class="co">;; timelime of timelines</span></span>
<span id="cb14-6"><a aria-hidden="true" href="#cb14-6" tabindex="-1"></a>[{<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>,</span>
<span id="cb14-7"><a aria-hidden="true" href="#cb14-7" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}]} </span>
<span id="cb14-8"><a aria-hidden="true" href="#cb14-8" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>,</span>
<span id="cb14-9"><a aria-hidden="true" href="#cb14-9" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb14-10"><a aria-hidden="true" href="#cb14-10" tabindex="-1"></a>         {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}]</span></code></pre></div>
<p>This implementation of this would be:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb15-1"><a aria-hidden="true" href="#cb15-1" tabindex="-1"></a><span class="co">;; tot = timeline of timelines</span></span>
<span id="cb15-2"><a aria-hidden="true" href="#cb15-2" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> update-timeline-bitemporal </span>[tot new-data from to know-date]</span>
<span id="cb15-3"><a aria-hidden="true" href="#cb15-3" tabindex="-1"></a>  (update-timeline tot</span>
<span id="cb15-4"><a aria-hidden="true" href="#cb15-4" tabindex="-1"></a>   (update-timeline (<span class="at">:data</span> (<span class="kw">last</span> tot)) new-data from to)</span>
<span id="cb15-5"><a aria-hidden="true" href="#cb15-5" tabindex="-1"></a>   know-date <span class="va">nil</span>))</span>
<span id="cb15-6"><a aria-hidden="true" href="#cb15-6" tabindex="-1"></a>   </span>
<span id="cb15-7"><a aria-hidden="true" href="#cb15-7" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> update-timeline </span>[timeline new-data from-date to-date] </span>
<span id="cb15-8"><a aria-hidden="true" href="#cb15-8" tabindex="-1"></a>  (<span class="kw">-&gt;&gt;</span> timeline</span>
<span id="cb15-9"><a aria-hidden="true" href="#cb15-9" tabindex="-1"></a>       (<span class="kw">mapcat</span> #(eliminate-overlap from-date to-date <span class="va">%</span>))</span>
<span id="cb15-10"><a aria-hidden="true" href="#cb15-10" tabindex="-1"></a>       (<span class="kw">cons</span> {<span class="at">:from-date</span> from-date, <span class="at">:to-date</span> to-date <span class="at">:data</span> new-data})</span>
<span id="cb15-11"><a aria-hidden="true" href="#cb15-11" tabindex="-1"></a>       (<span class="kw">sort-by</span> <span class="at">:from-date</span>)</span>
<span id="cb15-12"><a aria-hidden="true" href="#cb15-12" tabindex="-1"></a>       <span class="kw">vec</span>))</span>
<span id="cb15-13"><a aria-hidden="true" href="#cb15-13" tabindex="-1"></a></span>
<span id="cb15-14"><a aria-hidden="true" href="#cb15-14" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> eliminate-overlap </span>[from to entry]</span>
<span id="cb15-15"><a aria-hidden="true" href="#cb15-15" tabindex="-1"></a>  (<span class="kw">case</span> (overlap from to (<span class="at">:from-date</span> entry) (<span class="at">:to-date</span> entry))</span>
<span id="cb15-16"><a aria-hidden="true" href="#cb15-16" tabindex="-1"></a>    <span class="at">:full</span>    []</span>
<span id="cb15-17"><a aria-hidden="true" href="#cb15-17" tabindex="-1"></a>    <span class="at">:contain</span> [(<span class="kw">assoc</span> entry <span class="at">:to-date</span> from) (<span class="kw">assoc</span> entry <span class="at">:from-date</span> to)]</span>
<span id="cb15-18"><a aria-hidden="true" href="#cb15-18" tabindex="-1"></a>    <span class="at">:left</span>    [(<span class="kw">assoc</span> entry <span class="at">:to-date</span> from)]</span>
<span id="cb15-19"><a aria-hidden="true" href="#cb15-19" tabindex="-1"></a>    <span class="at">:right</span>   [(<span class="kw">assoc</span> entry <span class="at">:from-date</span> to)]</span>
<span id="cb15-20"><a aria-hidden="true" href="#cb15-20" tabindex="-1"></a>    <span class="at">:none</span>    [entry]))</span>
<span id="cb15-21"><a aria-hidden="true" href="#cb15-21" tabindex="-1"></a>    </span>
<span id="cb15-22"><a aria-hidden="true" href="#cb15-22" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> overlap </span>[new-from new-to old-from old-to]</span>
<span id="cb15-23"><a aria-hidden="true" href="#cb15-23" tabindex="-1"></a>  (<span class="kw">cond</span></span>
<span id="cb15-24"><a aria-hidden="true" href="#cb15-24" tabindex="-1"></a>    (d&lt; old-from new-from new-to old-to)  <span class="at">:contain</span></span>
<span id="cb15-25"><a aria-hidden="true" href="#cb15-25" tabindex="-1"></a>    (d&lt;= new-from old-from old-to new-to) <span class="at">:full</span></span>
<span id="cb15-26"><a aria-hidden="true" href="#cb15-26" tabindex="-1"></a>    (d&lt;= old-from new-from old-to)        <span class="at">:left</span></span>
<span id="cb15-27"><a aria-hidden="true" href="#cb15-27" tabindex="-1"></a>    (d&lt;= old-from new-to old-to)          <span class="at">:right</span></span>
<span id="cb15-28"><a aria-hidden="true" href="#cb15-28" tabindex="-1"></a>    <span class="at">:else</span>                                 <span class="at">:none</span>))</span></code></pre></div>
<p>The bitemporal update is just updating the <em>outer</em> timeline
<em>with</em> the update of the inner timeline. The update itself places
the new timeline entry in the timeline, and detects and resolves any
overlaps, adjusting dates and deleting entries as required. Note the
<code>d&lt;</code> functions are just ordering predicates for whatever
representation of dates you’re using.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb16-1"><a aria-hidden="true" href="#cb16-1" tabindex="-1"></a>(update-timeline-bitemporal</span>
<span id="cb16-2"><a aria-hidden="true" href="#cb16-2" tabindex="-1"></a>  <span class="co">;; first timeline: when we only knew the old name from 1-15 -&gt; 2-15</span></span>
<span id="cb16-3"><a aria-hidden="true" href="#cb16-3" tabindex="-1"></a> [{<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>,</span>
<span id="cb16-4"><a aria-hidden="true" href="#cb16-4" tabindex="-1"></a>   <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}]} </span>
<span id="cb16-5"><a aria-hidden="true" href="#cb16-5" tabindex="-1"></a>  <span class="co">;; second timeline: the current one, after we found out the </span></span>
<span id="cb16-6"><a aria-hidden="true" href="#cb16-6" tabindex="-1"></a>  <span class="co">;; new name on 2-15</span></span>
<span id="cb16-7"><a aria-hidden="true" href="#cb16-7" tabindex="-1"></a>  {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>,</span>
<span id="cb16-8"><a aria-hidden="true" href="#cb16-8" tabindex="-1"></a>   <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb16-9"><a aria-hidden="true" href="#cb16-9" tabindex="-1"></a>          {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}]</span>
<span id="cb16-10"><a aria-hidden="true" href="#cb16-10" tabindex="-1"></a>   <span class="co">;; adding a third name, valid from 3-1, known on 3-15</span></span>
<span id="cb16-11"><a aria-hidden="true" href="#cb16-11" tabindex="-1"></a>   <span class="st">&quot;Third Name&quot;</span> <span class="st">&quot;03-01&quot;</span> <span class="va">nil</span> <span class="st">&quot;03-15&quot;</span>)</span>
<span id="cb16-12"><a aria-hidden="true" href="#cb16-12" tabindex="-1"></a><span class="co">;;=&gt;</span></span>
<span id="cb16-13"><a aria-hidden="true" href="#cb16-13" tabindex="-1"></a>[<span class="co">;; unchanged</span></span>
<span id="cb16-14"><a aria-hidden="true" href="#cb16-14" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>, </span>
<span id="cb16-15"><a aria-hidden="true" href="#cb16-15" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}]}</span>
<span id="cb16-16"><a aria-hidden="true" href="#cb16-16" tabindex="-1"></a> <span class="co">;; updated to date. This is now the state of system knowledge until</span></span>
<span id="cb16-17"><a aria-hidden="true" href="#cb16-17" tabindex="-1"></a> <span class="co">;; 3-15</span></span>
<span id="cb16-18"><a aria-hidden="true" href="#cb16-18" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span>,<span class="at">:to-date</span> <span class="st">&quot;03-15&quot;</span>,</span>
<span id="cb16-19"><a aria-hidden="true" href="#cb16-19" tabindex="-1"></a> <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>} </span>
<span id="cb16-20"><a aria-hidden="true" href="#cb16-20" tabindex="-1"></a>        {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}</span>
<span id="cb16-21"><a aria-hidden="true" href="#cb16-21" tabindex="-1"></a> <span class="co">;; new timeline-of-timeline, valid from 3-15</span></span>
<span id="cb16-22"><a aria-hidden="true" href="#cb16-22" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;03-15&quot;</span>,<span class="at">:to-date</span> <span class="va">nil</span>,</span>
<span id="cb16-23"><a aria-hidden="true" href="#cb16-23" tabindex="-1"></a> <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb16-24"><a aria-hidden="true" href="#cb16-24" tabindex="-1"></a>        <span class="co">;; inner update has put a 'to date' to the actual change of name</span></span>
<span id="cb16-25"><a aria-hidden="true" href="#cb16-25" tabindex="-1"></a>        {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;03-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}</span>
<span id="cb16-26"><a aria-hidden="true" href="#cb16-26" tabindex="-1"></a>        <span class="co">;; and added the 3rd entry for the third name</span></span>
<span id="cb16-27"><a aria-hidden="true" href="#cb16-27" tabindex="-1"></a>        {<span class="at">:from-date</span> <span class="st">&quot;03-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Third Name&quot;</span>}]}]</span>
<span id="cb16-28"><a aria-hidden="true" href="#cb16-28" tabindex="-1"></a>        </span>
<span id="cb16-29"><a aria-hidden="true" href="#cb16-29" tabindex="-1"></a>(update-timeline-bitemporal</span>
<span id="cb16-30"><a aria-hidden="true" href="#cb16-30" tabindex="-1"></a> <span class="co">;; initial tot is the same</span></span>
<span id="cb16-31"><a aria-hidden="true" href="#cb16-31" tabindex="-1"></a> [{<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>,</span>
<span id="cb16-32"><a aria-hidden="true" href="#cb16-32" tabindex="-1"></a>   <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}]}</span>
<span id="cb16-33"><a aria-hidden="true" href="#cb16-33" tabindex="-1"></a>  {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>,</span>
<span id="cb16-34"><a aria-hidden="true" href="#cb16-34" tabindex="-1"></a>   <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb16-35"><a aria-hidden="true" href="#cb16-35" tabindex="-1"></a>          {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}]</span>
<span id="cb16-36"><a aria-hidden="true" href="#cb16-36" tabindex="-1"></a> <span class="co">;; but now we are inserting a name into the history</span></span>
<span id="cb16-37"><a aria-hidden="true" href="#cb16-37" tabindex="-1"></a> <span class="st">&quot;Tween Name&quot;</span> <span class="st">&quot;01-15&quot;</span> <span class="st">&quot;02-15&quot;</span> <span class="st">&quot;03-15&quot;</span>)</span>
<span id="cb16-38"><a aria-hidden="true" href="#cb16-38" tabindex="-1"></a><span class="co">;;=&gt;</span></span>
<span id="cb16-39"><a aria-hidden="true" href="#cb16-39" tabindex="-1"></a>[{<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>,</span>
<span id="cb16-40"><a aria-hidden="true" href="#cb16-40" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}]}</span>
<span id="cb16-41"><a aria-hidden="true" href="#cb16-41" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span> <span class="at">:to-date</span> <span class="st">&quot;03-15&quot;</span>,</span>
<span id="cb16-42"><a aria-hidden="true" href="#cb16-42" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb16-43"><a aria-hidden="true" href="#cb16-43" tabindex="-1"></a>         {<span class="at">:from-date</span> <span class="st">&quot;02-01&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}</span>
<span id="cb16-44"><a aria-hidden="true" href="#cb16-44" tabindex="-1"></a> {<span class="at">:from-date</span> <span class="st">&quot;03-15&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>,</span>
<span id="cb16-45"><a aria-hidden="true" href="#cb16-45" tabindex="-1"></a>  <span class="at">:data</span> [{<span class="at">:from-date</span> <span class="st">&quot;01-01&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Old Name&quot;</span>}</span>
<span id="cb16-46"><a aria-hidden="true" href="#cb16-46" tabindex="-1"></a>         {<span class="at">:from-date</span> <span class="st">&quot;01-15&quot;</span>, <span class="at">:to-date</span> <span class="st">&quot;02-15&quot;</span>, <span class="at">:data</span> <span class="st">&quot;Tween Name&quot;</span>}</span>
<span id="cb16-47"><a aria-hidden="true" href="#cb16-47" tabindex="-1"></a>         {<span class="at">:from-date</span> <span class="st">&quot;02-15&quot;</span>, <span class="at">:to-date</span> <span class="va">nil</span>, <span class="at">:data</span> <span class="st">&quot;New Name&quot;</span>}]}]</span></code></pre></div>
<h2 id="next">Next</h2>
<p>Persisting bitemporal timelines in a SQL Database</p>


</body></html>