<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8" /><meta content="pandoc" name="generator" /><meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport" /><title>2020_04_22_VietnamORM</title><style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style><style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style><link href="../../css/style.css" rel="stylesheet" /></head><body><h1 id="summary-orms-are-the-vietnam-of-computer-science">Summary: ORMS are the Vietnam of computer science</h1><div class="tufte-section"><div class="main-text"><p>This is based on <a href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/">Ted Neward’s Post</a> from June 2006. To editorialize a bit, the date seems important. 2006 was <em>deep</em> in the OO pit, and in particular the Java EE period. Concepts and practices that were considered standard at the time are now considered highly questionable, from the concept of OO itself to things like inheritance being accepted as a ‘way things are done’.</p><p>The US began the Vietnam war with unclear and conflicting goals, and disaster resulted. This article is about the parallels between that and ORM. ORM starts well, gets complicated, then gets monstrous. Early success yields a commitment to use it in places where success becomes more elusive. Know when to cut and run - ignore sunk costs. The author draws parallels to ORMs.</p></div><div class="sidenotes"></div></div><h2 id="impedance-mismatch">Impedance mismatch</h2><div class="tufte-section"><div class="main-text"><p>“Impedance mismatch” is about the differences between the Object vs. Relationship modeling paradigms. They are subtle but profound. With OO modeling, you encapsulate a (usually implicit) identity, state, and behavior. With relational modeling, you have storage of facts and predicate based retrieval logic.</p><p>The relational model is characterized by <em>relation, attribute, tuple, relation value,</em> and <em>relation variable</em>. For example, a <em>relation</em> <code>PERSON</code> might be defined as the <em>attributes</em> <code>{SSN, Name, City}</code>. The <em>tuple</em> is a truth statement in the context of the relation: <code>{PERSON SSN='123-45-6789' Name='Catherine Kennedy' City='Seattle'}</code>. The relation value is the combination of the relation and set of tuples that ‘match’ that relation (i.e. has the same attributes).</p><p>Unpacking these definitions to what I think are more everyday RDBM language gives the following:</p><ul>
<li>relation -&gt; table definition</li>
<li>attribute -&gt; column definition</li>
<li>tuple -&gt; table row</li>
<li>relation value -&gt; table (or set of table rows)</li>
</ul><p>From the above, it should be clear we’re effectively with working with <em>sets</em>. Two tuples/rows are identical if they contain the same attributes and attribute values. A table is a set of tuples/rows, meaning they can’t contain two of the ‘same’ row. You then use set operators: join, union, intersection, that allow for <em>‘derived relation values’</em>, such as the number of people living in individual cities from the people relation.</p></div><div class="sidenotes"></div></div><h2 id="object-relational-mapping">Object-Relational Mapping</h2><div class="tufte-section"><div class="main-text"><p>If you’re using an OO language and have relational storage, you always need to translate between the two. You have the following practical options:<sup>1</sup></p><ul>
<li>Automated tools, like hibernate.</li>
<li>Hand rolled</li>
<li>Just accept the relational schema as your OO model - slave the OO objects. Active Record is a variant of this.</li>
</ul><p>Slaving is the usual answer. In effect, it solves the problem by ignoring half of it.</p></div><div class="sidenotes"><p class="footnote">
1: Technically there’s another option to eliminate the mismatch: Go all in OO, and use an object database, or go all in RM without using an OO language. Object databases are currently out of fashion, and while there are more alternatives to OO these days than in 2006, it’s still the industry default.
</p></div></div><h2 id="the-object-to-table-problem">The Object to table problem</h2><div class="tufte-section"><div class="main-text"><p>So what actually is the problem? Can we not just say that OO classes are tables, class fields are columns, objects are rows? It sounds so easy. The problems are quite subtle. The problems start with <em>inheritance</em><sup>2</sup>. The relational model doesn’t support an ‘is-a’ relationship or polymorphism. Let’s look at the solutions available.</p></div><div class="sidenotes"><p class="footnote">
2: As mentioned earlier, this article was written at a time before the advisability of widespread inheritance relations was questioned. Likely articles like this were part of the literature which lead to that re-examination.
</p></div></div><h3 id="a-table-per-class.-simple-but-expensive">A table-per-class. Simple but expensive</h3><div class="tufte-section"><div class="main-text"><p>Each class gets it’s own table. Derived types are stitched together through joins. For example, a <code>Person</code> Class with a <code>Student</code> sub-class which itself has a <code>GraduateStudent</code> sub-class. You’d have a table for each, and you’d join across all 3 tables to get all the fields of the full object.</p><p>When you join, you need to join on the identity, which isn’t in the object itself. Where would you get it?<sup>3</sup></p><p>If you don’t want to manually specify the inheritance tree with each call, you’ll also have to have something in the database which does that - i.e. table pointers.</p><p>It’s also inefficient - three joins to bring one object into memory! It gets worse the more subclasses you add. A ‘get all people’ call gets crazy expensive.</p></div><div class="sidenotes"><p class="footnote">
3: I don’t really understand what he means here.
</p></div></div><h3 id="a-table-per-concrete-class">A table per concrete class</h3><div class="tufte-section"><div class="main-text"><p>More complex, a fair amount of duplication, but more efficient. It’s effectively de-normalizing.</p></div><div class="sidenotes"></div></div><h3 id="a-sparse-table-per-class-family-e.g.-student">A (sparse) table per class family (e.g. Student)</h3><div class="tufte-section"><div class="main-text"><p>Also de-normalizing. You’ll need to have a column for ‘subclass’. It introduces a lot of nulls, which is harmful to the integrity constraints that are one of the main benefits of an RMDBS.</p></div><div class="sidenotes"></div></div><h2 id="one-to-many-many-to-many-relationships">One-to-many, Many-to-many relationships</h2><div class="tufte-section"><div class="main-text"><p>1:N and M:N cardinalities are handled differently by OO and RDB. In fact they are handled in the <em>opposite</em> way. OO has unidirectional object traversal. An car object ‘has’ 4 tyre objects, and you would get to the tyre objects from the car object. It’s a ‘parent to child’ traversal.</p><p>RDB also has unidirectional traversal through FKs. But it’s in the opposite direction! A tyre would have an FK for the car it belongs to, but the Car table will have no reference to it’s tyres. For M:N relationships you need to have a 3rd ‘relationship’ table.</p><p>In both cases, you’ll need to do a broad (and thus inefficient) join to ‘discover’ relationships.</p></div><div class="sidenotes"></div></div><h2 id="schema-ownership-conflict---can-you-change-both">Schema-Ownership conflict - can you change both?</h2><div class="tufte-section"><div class="main-text"><p>ORM is predicated on the developer owning design of both schemas. Quite often this is not the case. Even if it is at first, over time devs will lose the ability to change the DB schema, as the database gets used downstream and implicitly coupled with those downstream processes<sup>4</sup>.</p><p>This all results in pressure to not have changes in the OO schema impact the DB schema. Which breaks the premise of ORM. The solution is often to create a separate, private database, resulting in complexity and silos.</p></div><div class="sidenotes"><p class="footnote">
4: Avoidance of this problem is one of the main motivations for the “Microservices” movement, which strictly limits the ability of downstream services to get at the database directly. Another interesting development is the <em>data warehouse</em>, which I believe was already coming into vogue at the time, and which also has the effect of decoupling downstream users from database implementations.
</p></div></div><h2 id="identity">Identity</h2><div class="tufte-section"><div class="main-text"><p>Objects have an identity (<em>this</em>) which is independent of its attributes. Usually it is implicit. Objects represent an <em>entity</em>, something which has an identity which is consistent even as its values change.</p><p>Relational models are best at storing <em>values</em>, not entities. i.e. if you have two rows in a table with identical field values, that’s usually considered a data corruption.<sup>5</sup></p><p>You run into transactional issues if entities are being accessed both via ORM and via SQL. This only increases with caching, which many ORM systems have built in.</p></div><div class="sidenotes"><p class="footnote">
5: it <em>can</em> handle entities with say auto-incrementing PKs, but it’s a bit inelegant
</p></div></div><h2 id="data-retrieval-concerns">Data retrieval concerns</h2><div class="tufte-section"><div class="main-text"><p>OO systems will use constructors to reconstruct objects. But these generally operate one at a time, so if you want to do a bunch of objects you need to do several round trips to the DB. The solution to this is one of 3 approaches:</p></div><div class="sidenotes"></div></div><h3 id="query-by-example">Query by example</h3><div class="tufte-section"><div class="main-text"><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">p <span class="op">=</span> Person()</a>
<a class="sourceLine" id="cb1-2" title="2">p.LastName <span class="op">=</span> <span class="st">&quot;Smith&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3">people <span class="op">=</span> QueryExecutor.execute(p)</a></code></pre></div><p>This isn’t nearly expressive enough for anything complicated. There’s no ability to say ‘find all people named Smith or Cromwell’ without complicating the API a lot. Domain objects <em>must</em> support nullable fields, which could violate model invariants.</p></div><div class="sidenotes"></div></div><h3 id="query-by-api">Query by API</h3><div class="tufte-section"><div class="main-text"><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">q <span class="op">=</span> Query()</a>
<a class="sourceLine" id="cb2-2" title="2">q.<span class="im">from</span>(<span class="st">&quot;PERSON&quot;</span>).Where(EqualsCriteria(<span class="st">&quot;PERSON.LAST_NAME&quot;</span>, <span class="st">&quot;SMITH&quot;</span>)people <span class="op">=</span> QueryExecutor.execute(q)</a></code></pre></div><p>This is more verbose and complicated that the actual SQL equivalent of the same query! Behind the scenes, the join logic is hard. Because you’re hardcoding the query params in strings, it’s easy to make mistakes. You can avoid this with unit tests, but it’s very easy to miss things. It’s very tightly coupled with the db schema. The dev has to know a lot about it, which nullifies one of the supposed benefits of ORM.</p></div><div class="sidenotes"></div></div><h3 id="query-by-language">Query by Language</h3><div class="tufte-section"><div class="main-text"><p>There are several languages which are meant to encode SQL logic in an Object call style: OQL, HQL. If you’re doing this, you no longer have an ORM. You’re just writing SQL with a different dialect - a dialect you have to learn!</p></div><div class="sidenotes"></div></div></body></html>