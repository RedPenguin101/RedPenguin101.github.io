<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8" />
  <meta content="pandoc" name="generator" />
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport" />
  <title>2020_04_22_VietnamORM</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="../../css/style.css" rel="stylesheet" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="summary-orms-are-the-vietnam-of-computer-science">Summary: ORMS
are the Vietnam of computer science</h1>
<p>This is based on <a href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/">Ted
Neward’s Post</a> from June 2006. To editorialize a bit, the date seems
important. 2006 was <em>deep</em> in the OO pit, and in particular the
Java EE period. Concepts and practices that were considered standard at
the time are now considered highly questionable, from the concept of OO
itself to things like inheritance being accepted as a ‘way things are
done’.</p>
<p>The US began the Vietnam war with unclear and conflicting goals, and
disaster resulted. This article is about the parallels between that and
ORM. ORM starts well, gets complicated, then gets monstrous. Early
success yields a commitment to use it in places where success becomes
more elusive. Know when to cut and run - ignore sunk costs. The author
draws parallels to ORMs.</p>
<h2 id="impedance-mismatch">Impedance mismatch</h2>
<p>“Impedance mismatch” is about the differences between the Object
vs. Relationship modeling paradigms. They are subtle but profound. With
OO modeling, you encapsulate a (usually implicit) identity, state, and
behavior. With relational modeling, you have storage of facts and
predicate based retrieval logic.</p>
<p>The relational model is characterized by <em>relation, attribute,
tuple, relation value,</em> and <em>relation variable</em>. For example,
a <em>relation</em> <code>PERSON</code> might be defined as the
<em>attributes</em> <code>{SSN, Name, City}</code>. The <em>tuple</em>
is a truth statement in the context of the relation:
<code>{PERSON SSN='123-45-6789' Name='Catherine Kennedy' City='Seattle'}</code>.
The relation value is the combination of the relation and set of tuples
that ‘match’ that relation (i.e. has the same attributes).</p>
<p>Unpacking these definitions to what I think are more everyday RDBM
language gives the following:</p>
<ul>
<li>relation -&gt; table definition</li>
<li>attribute -&gt; column definition</li>
<li>tuple -&gt; table row</li>
<li>relation value -&gt; table (or set of table rows)</li>
</ul>
<p>From the above, it should be clear we’re effectively with working
with <em>sets</em>. Two tuples/rows are identical if they contain the
same attributes and attribute values. A table is a set of tuples/rows,
meaning they can’t contain two of the ‘same’ row. You then use set
operators: join, union, intersection, that allow for <em>‘derived
relation values’</em>, such as the number of people living in individual
cities from the people relation.</p>
<h2 id="object-relational-mapping">Object-Relational Mapping</h2>
<p>If you’re using an OO language and have relational storage, you
always need to translate between the two. You have the following
practical
options:<sup class="fnref"><a href="#fn1" id="note1" title="Footnote 1">1</a></sup><span class="footnote" id="fn1">
<a class="fnref" href="#note1" title="Footnote 1 Reference">1</a>
Technically there’s another option to eliminate the mismatch: Go all in
OO, and use an object database, or go all in RM without using an OO
language. Object databases are currently out of fashion, and while there
are more alternatives to OO these days than in 2006, it’s still the
industry default. </span></p>

<ul>
<li>Automated tools, like hibernate.</li>
<li>Hand rolled</li>
<li>Just accept the relational schema as your OO model - slave the OO
objects. Active Record is a variant of this.</li>
</ul>
<p>Slaving is the usual answer. In effect, it solves the problem by
ignoring half of it.</p>
<h2 id="the-object-to-table-problem">The Object to table problem</h2>
<p>So what actually is the problem? Can we not just say that OO classes
are tables, class fields are columns, objects are rows? It sounds so
easy. The problems are quite subtle. The problems start with
<em>inheritance</em><sup class="fnref"><a href="#fn2" id="note2" title="Footnote 2">2</a></sup><span class="footnote" id="fn2">
<a class="fnref" href="#note2" title="Footnote 2 Reference">2</a> As
mentioned earlier, this article was written at a time before the
advisability of widespread inheritance relations was questioned. Likely
articles like this were part of the literature which lead to that
re-examination. </span>.
The relational model doesn’t support an ‘is-a’ relationship or
polymorphism. Let’s look at the solutions available.</p>

<h3 id="a-table-per-class.-simple-but-expensive">A table-per-class.
Simple but expensive</h3>
<p>Each class gets it’s own table. Derived types are stitched together
through joins. For example, a <code>Person</code> Class with a
<code>Student</code> sub-class which itself has a
<code>GraduateStudent</code> sub-class. You’d have a table for each, and
you’d join across all 3 tables to get all the fields of the full
object.</p>
<p>When you join, you need to join on the identity, which isn’t in the
object itself. Where would you get
it?<sup class="fnref"><a href="#fn3" id="note3" title="Footnote 3">3</a></sup><span class="footnote" id="fn3">
<a class="fnref" href="#note3" title="Footnote 3 Reference">3</a> I
don’t really understand what he means here. </span></p>

<p>If you don’t want to manually specify the inheritance tree with each
call, you’ll also have to have something in the database which does that
- i.e. table pointers.</p>
<p>It’s also inefficient - three joins to bring one object into memory!
It gets worse the more subclasses you add. A ‘get all people’ call gets
crazy expensive.</p>
<h3 id="a-table-per-concrete-class">A table per concrete class</h3>
<p>More complex, a fair amount of duplication, but more efficient. It’s
effectively de-normalizing.</p>
<h3 id="a-sparse-table-per-class-family-e.g.-student">A (sparse) table
per class family (e.g. Student)</h3>
<p>Also de-normalizing. You’ll need to have a column for ‘subclass’. It
introduces a lot of nulls, which is harmful to the integrity constraints
that are one of the main benefits of an RMDBS.</p>
<h2 id="one-to-many-many-to-many-relationships">One-to-many,
Many-to-many relationships</h2>
<p>1:N and M:N cardinalities are handled differently by OO and RDB. In
fact they are handled in the <em>opposite</em> way. OO has
unidirectional object traversal. An car object ‘has’ 4 tyre objects, and
you would get to the tyre objects from the car object. It’s a ‘parent to
child’ traversal.</p>
<p>RDB also has unidirectional traversal through FKs. But it’s in the
opposite direction! A tyre would have an FK for the car it belongs to,
but the Car table will have no reference to it’s tyres. For M:N
relationships you need to have a 3rd ‘relationship’ table.</p>
<p>In both cases, you’ll need to do a broad (and thus inefficient) join
to ‘discover’ relationships.</p>
<h2 id="schema-ownership-conflict---can-you-change-both">Schema-Ownership
conflict - can you change both?</h2>
<p>ORM is predicated on the developer owning design of both schemas.
Quite often this is not the case. Even if it is at first, over time devs
will lose the ability to change the DB schema, as the database gets used
downstream and implicitly coupled with those downstream
processes<sup class="fnref"><a href="#fn4" id="note4" title="Footnote 4">4</a></sup><span class="footnote" id="fn4">
<a class="fnref" href="#note4" title="Footnote 4 Reference">4</a>
Avoidance of this problem is one of the main motivations for the
“Microservices” movement, which strictly limits the ability of
downstream services to get at the database directly. Another interesting
development is the <em>data warehouse</em>, which I believe was already
coming into vogue at the time, and which also has the effect of
decoupling downstream users from database implementations. </span>.</p>

<p>This all results in pressure to not have changes in the OO schema
impact the DB schema. Which breaks the premise of ORM. The solution is
often to create a separate, private database, resulting in complexity
and silos.</p>
<h2 id="identity">Identity</h2>
<p>Objects have an identity (<em>this</em>) which is independent of its
attributes. Usually it is implicit. Objects represent an
<em>entity</em>, something which has an identity which is consistent
even as its values change.</p>
<p>Relational models are best at storing <em>values</em>, not entities.
i.e. if you have two rows in a table with identical field values, that’s
usually considered a data
corruption.<sup class="fnref"><a href="#fn5" id="note5" title="Footnote 5">5</a></sup><span class="footnote" id="fn5">
<a class="fnref" href="#note5" title="Footnote 5 Reference">5</a> it
<em>can</em> handle entities with say auto-incrementing PKs, but it’s a
bit inelegant </span></p>

<p>You run into transactional issues if entities are being accessed both
via ORM and via SQL. This only increases with caching, which many ORM
systems have built in.</p>
<h2 id="data-retrieval-concerns">Data retrieval concerns</h2>
<p>OO systems will use constructors to reconstruct objects. But these
generally operate one at a time, so if you want to do a bunch of objects
you need to do several round trips to the DB. The solution to this is
one of 3 approaches:</p>
<h3 id="query-by-example">Query by example</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a>p <span class="op">=</span> Person()</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a>p.LastName <span class="op">=</span> <span class="st">&quot;Smith&quot;</span></span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a>people <span class="op">=</span> QueryExecutor.execute(p)</span></code></pre></div>
<p>This isn’t nearly expressive enough for anything complicated. There’s
no ability to say ‘find all people named Smith or Cromwell’ without
complicating the API a lot. Domain objects <em>must</em> support
nullable fields, which could violate model invariants.</p>
<h3 id="query-by-api">Query by API</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>q <span class="op">=</span> Query()</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>q.<span class="im">from</span>(<span class="st">&quot;PERSON&quot;</span>).Where(EqualsCriteria(<span class="st">&quot;PERSON.LAST_NAME&quot;</span>, <span class="st">&quot;SMITH&quot;</span>)people <span class="op">=</span> QueryExecutor.execute(q)</span></code></pre></div>
<p>This is more verbose and complicated that the actual SQL equivalent
of the same query! Behind the scenes, the join logic is hard. Because
you’re hardcoding the query params in strings, it’s easy to make
mistakes. You can avoid this with unit tests, but it’s very easy to miss
things. It’s very tightly coupled with the db schema. The dev has to
know a lot about it, which nullifies one of the supposed benefits of
ORM.</p>
<h3 id="query-by-language">Query by Language</h3>
<p>There are several languages which are meant to encode SQL logic in an
Object call style: OQL, HQL. If you’re doing this, you no longer have an
ORM. You’re just writing SQL with a different dialect - a dialect you
have to learn!</p>


</body></html>