<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta charset="utf-8" />
  <meta content="pandoc" name="generator" />
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport" />
  <title>pocket_general</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link href="../../css/style.css" rel="stylesheet" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="pocket-general">Pocket general</h1>
<p><a href="https://github.com/RedPenguin101/pocket-gettysburg">Github
repo</a></p>
<h2 id="introduction">Introduction</h2>
<p>Pocket General
(<strong>PG</strong>)<sup class="fnref"><a href="#fn1" id="note1" title="Footnote 1">1</a></sup><span class="footnote" id="fn1">
<a class="fnref" href="#note1" title="Footnote 1 Reference">1</a> You
can see from the source it’s had a couple of names, but Pocket General
is the one I’m currently going with. </span>
is a small US Civil War tactics game using <a href="https://github.com/quil/quil">Quil</a> as a UI. PG takes
inspiration from the simplicity, accessibility and retro aesthetic of
the <a href="https://en.wikipedia.org/wiki/Advance_Wars">Advance
Wars</a> series for the Game Boy Advance and subsequent handhelds.
However, it intends to add several elements more common in war games,
such as friendly fog of war, order delay, and morale, though few of
these are implemented in this
version<sup class="fnref"><a href="#fn2" id="note2" title="Footnote 2">2</a></sup><span class="footnote" id="fn2">
<a class="fnref" href="#note2" title="Footnote 2 Reference">2</a> I
actually had a much more advanced version of this knocking around, with
some of these features, and a pretty interesting real-time dispatch
system, but unfortunately it seems to have gotten lost in some migration
or other. </span>.</p>

<p>I wrote it to explore the different patterns and concepts used in
developing a game, and to experience some of the challenges that
introduces. Talking about those will be the main focus of this document.
I’ve tried not to look at too much prior art, though I’ve read some
articles and posts about game code.</p>

<h2 id="quick-start">Quick Start</h2>
<p>You can launch the game from the REPL using <code>(ui/go)</code>.
This will launch the game with a default scenario, with the red team
starting. Or, you can build the project with <code>./build.sh</code> and
run the resulting uberjar, which will do the same thing.</p>
<figure>
<img alt="The Game" src="../../images/portfolio_pocket_general/game.png" />
<figcaption aria-hidden="true">The Game</figcaption>
</figure>
<p>Darker shaded squares are in ‘fog of war’, i.e. you can’t see in
them. Visibility (or ‘viewsheds’, see later) are blocked by trees and
hills, or extended if a unit is on a hill.</p>
<p>Move the cursor with the arrow keys (or <code>wasd</code>), and
select a unit with the space bar. This will highlight the movable area
for that unit. You can issue a move order by moving the cursor, which
will trace out a path for the unit. Note that terrain types affect
movement, with roads offering quicker transit than fields, and hills and
trees less than that. Confirm the order by hitting the space bar again,
and the unit will move.</p>
<p>You can end reds turn by pressing the ‘e’ key, which will mean it’s
blues turn. By selecting the unit in the hills you can the effect of
terrain on movement.</p>
<p>When you encounter an enemy unit, you can attack by moving next to
them, whereupon an ‘attack’ option will become available in the
menu.</p>
<h2 id="game-loop-and-game-state">Game loop and game state</h2>
<p>From what I’ve seen, most game implementations seem to revolve around
a ‘game loop’. There is a game state, and a method of transitioning this
game to the next ‘tick’ of that game-state. Transitioning includes:</p>
<ol type="1">
<li>Getting and processing user input (via ‘handlers’).</li>
<li>Applying various ‘systems’ to the various game
‘entities’<sup class="fnref"><a href="#fn3" id="note3" title="Footnote 3">3</a></sup>,
progressing the game state in time.</li>
<li>Drawing the resultant game state to the screen.</li>
</ol>

<p>This happens frequently, 30 or 60 times per second. Quil implements
this quite literally - here’s the slightly modified launch command,
where each value is a function.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a>(q/defsketch game</span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a>    ,,,</span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a>    <span class="at">:setup</span> setup</span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a>    <span class="at">:key-pressed</span> key-handler <span class="co">;; corresponds to step 1</span></span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a>    <span class="at">:update</span> tick             <span class="co">;; step 2</span></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>    <span class="at">:draw</span> draw-state         <span class="co">;; step 3</span></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a>    ,,,)</span></code></pre></div>
<p>The fundamental elements of the game are the game-state, the
handlers, the tick, and the draw.</p>
<p>The game state is just a map containing all the info about the game
at a point in time. All the fundamental operations of the game - input
handling, ticking, drawing, are functions on the game state. Here’s a
significantly abbreviated map of what the gamestate looks like during a
game.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a>{<span class="at">:turn-number</span> <span class="dv">1</span>,</span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a> <span class="at">:images</span> <span class="co">;; snip - a map of all the sprites used</span></span>
<span id="cb2-3"><a aria-hidden="true" href="#cb2-3" tabindex="-1"></a> <span class="at">:cursor</span> [<span class="dv">12</span> <span class="dv">8</span>],</span>
<span id="cb2-4"><a aria-hidden="true" href="#cb2-4" tabindex="-1"></a> <span class="at">:field</span> {[<span class="dv">8</span> <span class="dv">8</span>] {<span class="at">:grid</span> [<span class="dv">8</span> <span class="dv">8</span>], <span class="at">:terrain</span> <span class="at">:field</span>},</span>
<span id="cb2-5"><a aria-hidden="true" href="#cb2-5" tabindex="-1"></a>         [<span class="dv">11</span> <span class="dv">9</span>] {<span class="at">:grid</span> [<span class="dv">11</span> <span class="dv">9</span>], <span class="at">:terrain</span> <span class="at">:mountains</span>},</span>
<span id="cb2-6"><a aria-hidden="true" href="#cb2-6" tabindex="-1"></a>         [<span class="dv">7</span> <span class="dv">4</span>] {<span class="at">:grid</span> [<span class="dv">7</span> <span class="dv">4</span>], <span class="at">:dirs</span> [<span class="at">:dr</span>], <span class="at">:terrain</span> <span class="at">:road</span>},</span>
<span id="cb2-7"><a aria-hidden="true" href="#cb2-7" tabindex="-1"></a>         <span class="co">;; snip - this goes on for a while!</span></span>
<span id="cb2-8"><a aria-hidden="true" href="#cb2-8" tabindex="-1"></a>         }</span>
<span id="cb2-9"><a aria-hidden="true" href="#cb2-9" tabindex="-1"></a> <span class="at">:field-size</span> (<span class="dv">15</span> <span class="dv">10</span>),</span>
<span id="cb2-10"><a aria-hidden="true" href="#cb2-10" tabindex="-1"></a> <span class="at">:turn</span> <span class="at">:blue</span>,</span>
<span id="cb2-11"><a aria-hidden="true" href="#cb2-11" tabindex="-1"></a> <span class="at">:red</span></span>
<span id="cb2-12"><a aria-hidden="true" href="#cb2-12" tabindex="-1"></a> {<span class="at">:units</span> {<span class="st">&quot;c4070352-7cfa-45b7-926a-e99316830da0&quot;</span></span>
<span id="cb2-13"><a aria-hidden="true" href="#cb2-13" tabindex="-1"></a>   {<span class="at">:short-name</span> <span class="st">&quot;73rd&quot;</span>,</span>
<span id="cb2-14"><a aria-hidden="true" href="#cb2-14" tabindex="-1"></a>    <span class="at">:move-points</span> <span class="dv">3</span>,</span>
<span id="cb2-15"><a aria-hidden="true" href="#cb2-15" tabindex="-1"></a>    <span class="at">:max-move-points</span> <span class="dv">3</span>,</span>
<span id="cb2-16"><a aria-hidden="true" href="#cb2-16" tabindex="-1"></a>    <span class="at">:unit-type</span> <span class="at">:infantry</span>,</span>
<span id="cb2-17"><a aria-hidden="true" href="#cb2-17" tabindex="-1"></a>    <span class="at">:soldiers</span> <span class="dv">1000</span>,</span>
<span id="cb2-18"><a aria-hidden="true" href="#cb2-18" tabindex="-1"></a>   <span class="at">:movement-table</span> {<span class="at">:field</span> <span class="dv">1</span>, <span class="at">:road</span> <span class="fl">0.5</span>, <span class="at">:trees</span> <span class="dv">1</span>, <span class="at">:mountains</span> <span class="dv">2</span>},</span>
<span id="cb2-19"><a aria-hidden="true" href="#cb2-19" tabindex="-1"></a>    <span class="at">:move-over</span> <span class="va">false</span>,</span>
<span id="cb2-20"><a aria-hidden="true" href="#cb2-20" tabindex="-1"></a>    <span class="at">:viewshed</span> #{[<span class="dv">8</span> <span class="dv">8</span>] <span class="co">;; and other coordinates</span></span>
<span id="cb2-21"><a aria-hidden="true" href="#cb2-21" tabindex="-1"></a>                },</span>
<span id="cb2-22"><a aria-hidden="true" href="#cb2-22" tabindex="-1"></a>    <span class="at">:id</span> <span class="st">&quot;c4070352-7cfa-45b7-926a-e99316830da0&quot;</span>,</span>
<span id="cb2-23"><a aria-hidden="true" href="#cb2-23" tabindex="-1"></a>    <span class="at">:side</span> <span class="at">:red</span>,</span>
<span id="cb2-24"><a aria-hidden="true" href="#cb2-24" tabindex="-1"></a>    <span class="at">:unit-name</span> <span class="st">&quot;73rd New York Regiment&quot;</span>,</span>
<span id="cb2-25"><a aria-hidden="true" href="#cb2-25" tabindex="-1"></a>    <span class="at">:position</span> [<span class="dv">8</span> <span class="dv">4</span>]}}}</span>
<span id="cb2-26"><a aria-hidden="true" href="#cb2-26" tabindex="-1"></a>  <span class="at">:blue</span> {<span class="at">:units</span> <span class="co">;; other units </span></span>
<span id="cb2-27"><a aria-hidden="true" href="#cb2-27" tabindex="-1"></a>         }</span>
<span id="cb2-28"><a aria-hidden="true" href="#cb2-28" tabindex="-1"></a>  <span class="at">:camera</span> [<span class="dv">0</span> <span class="dv">0</span>],</span>
<span id="cb2-29"><a aria-hidden="true" href="#cb2-29" tabindex="-1"></a>  <span class="at">:ticks</span> <span class="dv">27383</span>,</span>
<span id="cb2-30"><a aria-hidden="true" href="#cb2-30" tabindex="-1"></a>  <span class="at">:order-queue</span> ()}</span></code></pre></div>
<h2 id="ui-and-ui-layers">UI and UI Layers</h2>
<p>The UI library is Quil. The UI namespace itself contains any calls to
the Quil API, with domain specific functions like
<code>draw-attack-cursor</code>, <code>draw-unit</code>,
<code>draw-menu</code>, as well as more generic draw functions which
mostly compose these - <code>draw-sprite</code>,
<code>draw-tile</code>.</p>
<p>The main function of the UI namespace is
<code>draw-state :: game-state</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb3-1"><a aria-hidden="true" href="#cb3-1" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> draw-state </span>[game-state]</span>
<span id="cb3-2"><a aria-hidden="true" href="#cb3-2" tabindex="-1"></a>  (<span class="kw">let</span> [{<span class="at">:keys</span> [images camera]} (layers/constants game-state)]</span>
<span id="cb3-3"><a aria-hidden="true" href="#cb3-3" tabindex="-1"></a>    (draw-terrain (layers/field-layer game-state) images camera)</span>
<span id="cb3-4"><a aria-hidden="true" href="#cb3-4" tabindex="-1"></a>    (draw-units (layers/unit-layer game-state) camera)</span>
<span id="cb3-5"><a aria-hidden="true" href="#cb3-5" tabindex="-1"></a>    (draw-intel (layers/intel-layer game-state) camera)</span>
<span id="cb3-6"><a aria-hidden="true" href="#cb3-6" tabindex="-1"></a>    (draw-highlights (layers/highlight-layer game-state) camera)</span>
<span id="cb3-7"><a aria-hidden="true" href="#cb3-7" tabindex="-1"></a>    <span class="co">;; etc. for other layers</span></span>
<span id="cb3-8"><a aria-hidden="true" href="#cb3-8" tabindex="-1"></a>    ))</span></code></pre></div>
<p>The draw-state comprises several more specific function, each of
which successively draws a ‘layer’ of the game state, starting with the
terrain, then the units, etc. In this way, modifications to different
elements of the UI are effectively decoupled for change, and the system
is extensible to new elements by adding new layers. Additionally, the
drawing functions are decoupled from the game-state implementation
itself via the <code>layers</code> name-space, which provides functions
to filter and format information from the game state relevant to that
layer. Some of these are simple pass-throughs, like
<code>(defn highlight-layer [game-state] (:highlight game-state))</code>.
Some have some logic in them, such as this one, which limits the units
which are passed to the UI to draw to those which belong to the player,
or which are in the players line of sight.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb4-1"><a aria-hidden="true" href="#cb4-1" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> unit-layer </span>[game-state]</span>
<span id="cb4-2"><a aria-hidden="true" href="#cb4-2" tabindex="-1"></a>  (<span class="kw">let</span> [my-side (<span class="at">:turn</span> game-state)</span>
<span id="cb4-3"><a aria-hidden="true" href="#cb4-3" tabindex="-1"></a>        my-units (forces/units game-state my-side)</span>
<span id="cb4-4"><a aria-hidden="true" href="#cb4-4" tabindex="-1"></a>        viewsheds (<span class="kw">or</span> (vs/all-viewsheds game-state) #{})</span>
<span id="cb4-5"><a aria-hidden="true" href="#cb4-5" tabindex="-1"></a>        visible-enemy-units (<span class="kw">filter</span> #(viewsheds (<span class="at">:position</span> <span class="va">%</span>)) (forces/units game-state (other-side my-side)))]</span>
<span id="cb4-6"><a aria-hidden="true" href="#cb4-6" tabindex="-1"></a>    (<span class="kw">concat</span> my-units visible-enemy-units)))</span></code></pre></div>
<h2 id="bresenham-rasterization-calculating-viewsheds">Bresenham,
Rasterization, Calculating Viewsheds</h2>
<p>One concept that I hadn’t heard of before I worked on this was the
Bresenham Algorithms. Often when you want to draw something, you find
yourself working in a continuous vector space, and need to transfer this
to a <em>discrete</em> vector space - for example, a screen made of
pixels. Let’s say you want to draw a line on a pixelated screen. If the
line is perfectly horizontal or vertical, no problem. But if the line is
<em>diagonal</em>, how do you figure out which pixels you need to shade?
This problem obviously extends to any shape made of straight lines, but
also circles, which is relevant to the game.</p>
<figure>
<img alt="Bresenham Line" src="../../images/portfolio_pocket_general/Bresenham.svg" />
<figcaption aria-hidden="true">Bresenham Line</figcaption>
</figure>
<p>This is the problem that <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham’s
algorithm</a> (in line and circle variants) solves. I won’t go into how
the algorithm works, but it becomes necessary in the game for
calculating how far a unit can see around them (“viewsheds”) A unit can
see around them in all directions to ‘x’ spaces. To calculate this, you
say a unit can see around them in a circle of radius 5. Bresenham’s
circle algorithm will determine the ‘edges’ of the circle. Bresenhams’
<em>line</em> algorithm will draw a ‘path’ from the unit to each
coordinate on the edge of the circle. The resultant set of coordinates
are the things the unit can see, aka it’s viewshed.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb5-1"><a aria-hidden="true" href="#cb5-1" tabindex="-1"></a>(draw-points (bresenham-circle [<span class="dv">5</span> <span class="dv">5</span>] <span class="dv">4</span>))</span>
<span id="cb5-2"><a aria-hidden="true" href="#cb5-2" tabindex="-1"></a></span>
<span id="cb5-3"><a aria-hidden="true" href="#cb5-3" tabindex="-1"></a>[. . # # # # # . .]</span>
<span id="cb5-4"><a aria-hidden="true" href="#cb5-4" tabindex="-1"></a>[. # . . . . . # .]</span>
<span id="cb5-5"><a aria-hidden="true" href="#cb5-5" tabindex="-1"></a>[# . . . . . . . #]</span>
<span id="cb5-6"><a aria-hidden="true" href="#cb5-6" tabindex="-1"></a>[# . . . . . . . #]</span>
<span id="cb5-7"><a aria-hidden="true" href="#cb5-7" tabindex="-1"></a>[# . . . U . . . #]</span>
<span id="cb5-8"><a aria-hidden="true" href="#cb5-8" tabindex="-1"></a>[# . . . . . . . #]</span>
<span id="cb5-9"><a aria-hidden="true" href="#cb5-9" tabindex="-1"></a>[# . . . . . . . #]</span>
<span id="cb5-10"><a aria-hidden="true" href="#cb5-10" tabindex="-1"></a>[. # . . . . . # .]</span>
<span id="cb5-11"><a aria-hidden="true" href="#cb5-11" tabindex="-1"></a>[. . # # # # # . .]</span>
<span id="cb5-12"><a aria-hidden="true" href="#cb5-12" tabindex="-1"></a></span>
<span id="cb5-13"><a aria-hidden="true" href="#cb5-13" tabindex="-1"></a><span class="co">;; from viewshed namespace</span></span>
<span id="cb5-14"><a aria-hidden="true" href="#cb5-14" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> paths </span>[n loc]</span>
<span id="cb5-15"><a aria-hidden="true" href="#cb5-15" tabindex="-1"></a>  (<span class="kw">let</span> [edges (<span class="kw">set</span> (br/bresenham-circle loc n))]</span>
<span id="cb5-16"><a aria-hidden="true" href="#cb5-16" tabindex="-1"></a>    (<span class="kw">for</span> [point edges]</span>
<span id="cb5-17"><a aria-hidden="true" href="#cb5-17" tabindex="-1"></a>      (<span class="kw">rest</span> (br/bresenham-line loc point)))))</span></code></pre></div>
<p>You do need to make some line-of-sight adjustments though. For
example, a tree tile is not in a unit’s viewshed unless they are
standing right next to it, and they also block sight of any tiles behind
the trees. Mountains are similar in that they block line of sight,
though the mountain <em>itself</em> is included in the viewshed. Lastly,
if a unit is standing on a mountain, the radius of the viewshed is
increased. Each path is ‘walked’ to account for any terrain effects:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb6-1"><a aria-hidden="true" href="#cb6-1" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> walk-path </span>[<span class="kw">path</span> loc tile-terrain]</span>
<span id="cb6-2"><a aria-hidden="true" href="#cb6-2" tabindex="-1"></a>  (<span class="kw">reduce</span> (<span class="kw">fn</span> [out-path next-tile]</span>
<span id="cb6-3"><a aria-hidden="true" href="#cb6-3" tabindex="-1"></a>            (<span class="kw">case</span> (<span class="kw">get</span> tile-terrain next-tile)</span>
<span id="cb6-4"><a aria-hidden="true" href="#cb6-4" tabindex="-1"></a>              <span class="at">:trees</span> (reduced (<span class="kw">if</span> (<span class="kw">and</span> (adjacent? loc next-tile) (<span class="kw">empty?</span> out-path))</span>
<span id="cb6-5"><a aria-hidden="true" href="#cb6-5" tabindex="-1"></a>                                [next-tile] </span>
<span id="cb6-6"><a aria-hidden="true" href="#cb6-6" tabindex="-1"></a>                                out-path))</span>
<span id="cb6-7"><a aria-hidden="true" href="#cb6-7" tabindex="-1"></a>              <span class="at">:mountains</span> (reduced (<span class="kw">conj</span> out-path next-tile))</span>
<span id="cb6-8"><a aria-hidden="true" href="#cb6-8" tabindex="-1"></a>              (<span class="kw">conj</span> out-path next-tile)))</span>
<span id="cb6-9"><a aria-hidden="true" href="#cb6-9" tabindex="-1"></a>          []</span>
<span id="cb6-10"><a aria-hidden="true" href="#cb6-10" tabindex="-1"></a>          <span class="kw">path</span>))</span></code></pre></div>
<h2 id="modeling-orders">Modeling orders</h2>
<p>The game loop is premised on an order system. Orders are issued to
units, and a queue of these orders is stored in the game state. A ‘game
tick’ is, in effect, just the processing of the next order in the queue,
implemented in the (poorly named) <code>inputs</code> namespace. If
there’s a current order, execute it (by a switch conditional on the
order type). If there’s no current order, but there are order on the
order queue, promote the head of the order queue to the current order.
If there are no orders, do nothing - this function should only be called
when there are orders in the queue.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1" tabindex="-1"></a><span class="co">;; in inputs namespace</span></span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> execute-next-order </span>[game-state]</span>
<span id="cb7-3"><a aria-hidden="true" href="#cb7-3" tabindex="-1"></a>  (<span class="kw">cond</span> (<span class="at">:current-order</span> game-state)</span>
<span id="cb7-4"><a aria-hidden="true" href="#cb7-4" tabindex="-1"></a>        (<span class="kw">let</span> [[order-type side unit target] (<span class="at">:current-order</span> game-state)]</span>
<span id="cb7-5"><a aria-hidden="true" href="#cb7-5" tabindex="-1"></a>          (<span class="kw">case</span> order-type</span>
<span id="cb7-6"><a aria-hidden="true" href="#cb7-6" tabindex="-1"></a>            <span class="at">:move</span>     (execute-move-order game-state order-type side unit target)</span>
<span id="cb7-7"><a aria-hidden="true" href="#cb7-7" tabindex="-1"></a>            <span class="at">:retreat</span>  (execute-move-order game-state order-type side unit target)</span>
<span id="cb7-8"><a aria-hidden="true" href="#cb7-8" tabindex="-1"></a>            <span class="at">:attack</span>   (execute-attack-order game-state side unit target))</span>
<span id="cb7-9"><a aria-hidden="true" href="#cb7-9" tabindex="-1"></a>            <span class="at">:end-turn</span> (end-turn game-state side))</span>
<span id="cb7-10"><a aria-hidden="true" href="#cb7-10" tabindex="-1"></a></span>
<span id="cb7-11"><a aria-hidden="true" href="#cb7-11" tabindex="-1"></a>        (<span class="kw">not-empty</span> (<span class="at">:order-queue</span> game-state))</span>
<span id="cb7-12"><a aria-hidden="true" href="#cb7-12" tabindex="-1"></a>        (<span class="kw">-&gt;</span> game-state</span>
<span id="cb7-13"><a aria-hidden="true" href="#cb7-13" tabindex="-1"></a>            (<span class="kw">assoc</span> <span class="at">:current-order</span> (<span class="kw">first</span> (<span class="at">:order-queue</span> game-state)))</span>
<span id="cb7-14"><a aria-hidden="true" href="#cb7-14" tabindex="-1"></a>            (<span class="kw">update</span> <span class="at">:order-queue</span> <span class="kw">rest</span>))</span>
<span id="cb7-15"><a aria-hidden="true" href="#cb7-15" tabindex="-1"></a></span>
<span id="cb7-16"><a aria-hidden="true" href="#cb7-16" tabindex="-1"></a>        <span class="at">:else</span> (<span class="kw">do</span> (<span class="kw">println</span> <span class="st">&quot;Erroneous input handle&quot;</span>)</span>
<span id="cb7-17"><a aria-hidden="true" href="#cb7-17" tabindex="-1"></a>                  game-state)))</span></code></pre></div>
<p>(Note that ‘end turn’ is implemented as an order-type, along with
move, retreat and attack, which conflates two things. This is poor
design and should be fixed.)</p>
<p>An “order” is a tuple of <code>type + side + id + x</code>, where
<code>x</code> is dependent on the type of order. For example a Move
order would look like
<code>[:move :red :unit-a ([1 1] [1 2] [1 3])]</code>, where the last
element is the route the unit is planning to take. (Attack orders and
combat I’ll talk about separately.)</p>
<p>The order queue is intended to be a mechanism for decoupling what a
unit is doing from the source of what asked them to do it. Examples of
what can ‘make’ a unit do something are:</p>
<ul>
<li>The user, via a menu</li>
<li>The enemy AI commander</li>
<li>If you have a tiered system of command, the superior unit of another
unit, on either side</li>
<li>The <em>unit itself</em> can decide to do something, and that would
be implemented as an order - for example if a unit decides to retreat
from combat, it will issue itself an order to retreat.</li>
</ul>
<p>Once an order is issued it doesn’t matter how it originated, it’ll
get executed just the same.</p>
<h2 id="dispatches">Dispatches</h2>
<p>Orders represent an order a unit has <em>received</em>. However,
communication on a battlefield is not instantaneous. A commanding unit
sends a <em>dispatch</em> to a subordinate unit. These systems are
modeled separately in the game, for the following reasons:</p>
<ul>
<li>Order delay: an order can take time to reach the subordinate unit.
This delay can cover the time to create the order, and the time in
transit, which depends on the method of communication.</li>
<li>Dispatch reification: If the method is slow, like a horse runner,
then the runner has to traverse the terrain just like a unit itself.
There’s also the possibility that the runner can’t find the subordinate
unit, or the runner could be intercepted by the enemy. Separating
dispatches into a separate system allow for this reification.</li>
<li>Execution detail: when a superior unit asks a subordinate to do
something, the dispatch doesn’t have to include all information about
how to execute that request. For example the superior might ask the
subordinate to move to a particular location, but not specify what route
to take, which will be left to the subordinate to figure out
itself.</li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li>Input Handling</li>
<li>Routing</li>
<li>Combat</li>
<li>Intelligence</li>
</ul>


</body></html>