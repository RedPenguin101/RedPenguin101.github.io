<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-10 Sun 15:47 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Made Easy</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Joe" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Simple Made Easy</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org465ea54">1. The difference between Simple and Easy</a>
<ul>
<li><a href="#orgd930993">1.1. The Origins of the words</a></li>
<li><a href="#org93c88a6">1.2. Simple means is about something being one thing - not being interleaved with another thing</a></li>
<li><a href="#orgea728be">1.3. Easy is about how close to us something is</a></li>
<li><a href="#org35d7e8a">1.4. Distinguish the tool, the construct, from the artifact (the program, system, the thing that has to run)</a></li>
<li><a href="#org28b9ba0">1.5. To Complect - to interleave, entwine, braid, to make complex</a></li>
</ul>
</li>
<li><a href="#orga6cab0e">2. You understanding something is making it easy - being close to it, being able to reason about it</a>
<ul>
<li><a href="#orgbf40d64">2.1. Why? Because you can't effectively change something you can't reason about</a></li>
<li><a href="#orgc29ce55">2.2. Moving your mind to it vs. moving it towards your mind</a></li>
<li><a href="#org8cc1701">2.3. How reasonable something is is a function of how simple it is. How much <i>you</i> are able to reason about it is how easy it is (for <i>you</i>)</a></li>
<li><a href="#org857d6b6">2.4. Example 1: Parens in Lisp!</a></li>
<li><a href="#orgdc8858d">2.5. Programmers know the benefits of everything and the trade-offs of nothing.</a></li>
</ul>
</li>
<li><a href="#orgfd3f63f">3. Beware: Easy is dangerous if it hides complexity!</a>
<ul>
<li><a href="#orge46d4b9">3.1. Easy things are often extremely complex, and chosing the easy-yet-complex thing is incidental complexity (i.e. it's your fault)</a></li>
<li><a href="#org33ffc44">3.2. Choosing the easy-yet-complex makes you fast-at-first.</a></li>
</ul>
</li>
<li><a href="#orgef04723">4. Making things simple - simple constructs, abstractions, composability, data as data</a>
<ul>
<li><a href="#orgfea491d">4.1. Benefits of simplicity - Lego castles vs. knitted castles</a></li>
<li><a href="#org1bce3fa">4.2. Constructs: Complex -&gt; Simple</a>
<ul>
<li><a href="#org051c687">4.2.1. Table</a></li>
</ul>
</li>
<li><a href="#orgefa16c1">4.3. Abstraction for simplicity - draw away the complexity</a></li>
<li><a href="#org8007443">4.4. Composability (not physical separation)</a></li>
<li><a href="#org9aef35c">4.5. State is NEVER simple.</a></li>
<li><a href="#org7013b70">4.6. Environmental complexity - we can't do anything about it</a></li>
<li><a href="#org98f0f58">4.7. Example 2: Lists and Order (complecting the thing with it's neighbour)</a></li>
<li><a href="#org27bab5a">4.8. Example 3: Data/Information is simple</a></li>
<li><a href="#org733c9e7">4.9. Simplify during analysis, modelling, waaaay before you implement</a></li>
</ul>
</li>
<li><a href="#org91c94a9">5. Simplicity is a choice</a></li>
</ul>
</div>
</div>
<p>
<a href="https://www.youtube.com/watch?v=oytL881p-nQ">https://www.youtube.com/watch?v=oytL881p-nQ</a>
</p>

<p>
This talk is about the difference between ease and simplicity. And about how to take the simple, and make it easy - close at hand.
</p>

<blockquote>
<p>
Simplicity is prerequisite for reliability
&#x2014;Edsger W. Dijkstra
</p>
</blockquote>

<div id="outline-container-org465ea54" class="outline-2">
<h2 id="org465ea54"><span class="section-number-2">1</span> The difference between Simple and Easy</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd930993" class="outline-3">
<h3 id="orgd930993"><span class="section-number-3">1.1</span> The Origins of the words</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Simplex - one fold/braid.
(vs. complex - to braid together)
</p>

<p>
Ease - to lie near
</p>
</div>
</div>

<div id="outline-container-org93c88a6" class="outline-3">
<h3 id="org93c88a6"><span class="section-number-3">1.2</span> Simple means is about something being one thing - not being interleaved with another thing</h3>
<div class="outline-text-3" id="text-1-2">
<p>
One role, task, concept, dimension. Not one <i>instance</i>, one <i>operation</i>. It's about lack of interleaving, not about cardinality
</p>

<p>
Notice that Simplicity is objective, doesn't depend on your perspective
</p>
</div>
</div>

<div id="outline-container-orgea728be" class="outline-3">
<h3 id="orgea728be"><span class="section-number-3">1.3</span> Easy is about how close to us something is</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Construction 1: Literally close, its on our hard drive. In our tool box. Gem install
</p>

<p>
Construction 2: Near to our understanding, <i>familiar</i> to us
</p>

<p>
Construction 3: Near our <i>capabilities</i> - tough to talk about, an ego hit! But it's important to recognise we have limits.
</p>

<p>
The juggling analogy: A beginner juggler can juggle 3 things. How many can an expert juggle? More for sure (the record is 11). But not 500. not 1000.
</p>

<p>
Ease is <i>relative</i> - near to what? Something near to / easy to you might not be easy to me
</p>
</div>
</div>

<div id="outline-container-org35d7e8a" class="outline-3">
<h3 id="org35d7e8a"><span class="section-number-3">1.4</span> Distinguish the tool, the construct, from the artifact (the program, system, the thing that has to run)</h3>
<div class="outline-text-3" id="text-1-4">
<p>
to be changable, the Artifact has to be simple. The tools don't matter except to that extent
</p>
</div>
</div>

<div id="outline-container-org28b9ba0" class="outline-3">
<h3 id="org28b9ba0"><span class="section-number-3">1.5</span> To Complect - to interleave, entwine, braid, to make complex</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Don't do it!
</p>

<p>
"where does the third strand end?"
</p>

<p>
If you want to move forward you have to fix it (Even though it wasn't a 'mistake'). Disentangle
</p>
</div>
</div>
</div>

<div id="outline-container-orga6cab0e" class="outline-2">
<h2 id="orga6cab0e"><span class="section-number-2">2</span> You understanding something is making it easy - being close to it, being able to reason about it</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgbf40d64" class="outline-3">
<h3 id="orgbf40d64"><span class="section-number-3">2.1</span> Why? Because you can't effectively change something you can't reason about</h3>
<div class="outline-text-3" id="text-2-1">
<p>
If you can't you can't change it. And the more simple something is, the more you can reason about it.
</p>

<p>
Inherent limits on our ability to reason about things do exist. We can only consider a few things at a time. If two things are intertwined, they by definition have to be considered together, and so you use up (exponentially with every thread) the space in your head.
</p>

<p>
Understanding is a prerequisite for Change - if you can't reason about it you can't make decisions about it
</p>

<p>
Having a great test suite isn't enough, it's your ability to understand your software. (If you haven't thought about a thing, you can't have written  test for it!)
</p>

<p>
Debugging - You can't lean on it too much. Bugs in production by definition passed the typechecker, passed all the tests.
</p>
</div>
</div>

<div id="outline-container-orgc29ce55" class="outline-3">
<h3 id="orgc29ce55"><span class="section-number-3">2.2</span> Moving your mind to it vs. moving it towards your mind</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Lets say you have this big thing you need make to easy, bring it close to you, understand
</p>

<p>
To make it physically near, accessible, get it on your box! You then can learn about it. take some courses, read some books.
</p>

<p>
(These two are up to you!)
</p>

<p>
The 3rd thing? The capability? Pretty tricky. You can't move your mental capability by much. You can't become orders of magnitude smarter
</p>

<p>
So you can't move your mind closer appreciably closer to the thing. You have to move the thing closer to your mind. You do this by making things simpler.
</p>
</div>
</div>

<div id="outline-container-org8cc1701" class="outline-3">
<h3 id="org8cc1701"><span class="section-number-3">2.3</span> How reasonable something is is a function of how simple it is. How much <i>you</i> are able to reason about it is how easy it is (for <i>you</i>)</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Obviously, you want something to be simple, so it takes less time for you and others to understand it (i.e. bring it close to them)
</p>
</div>
</div>

<div id="outline-container-org857d6b6" class="outline-3">
<h3 id="org857d6b6"><span class="section-number-3">2.4</span> Example 1: Parens in Lisp!</h3>
<div class="outline-text-3" id="text-2-4">
<p>
They are hard - they're not nearby, you're not familiar with them
</p>

<p>
Are they simple? NO. Not in CL/Scheme at least, because they use lists (with parens) for everything. One thing isn't simple? No becuase have to represent everything, they are overloaded with a lot of responsibility. Overloading is complexity. More than one thing is simpler than one thing in this case!
</p>

<p>
(This is a general principle - overloading one thing with multiple interpretations/responsibilities is introducing complexity)
</p>

<p>
This is why clojure introduced multiple paren types to reduce the overloading, make it simpler
</p>
</div>
</div>

<div id="outline-container-orgdc8858d" class="outline-3">
<h3 id="orgdc8858d"><span class="section-number-3">2.5</span> Programmers know the benefits of everything and the trade-offs of nothing.</h3>
<div class="outline-text-3" id="text-2-5">
<p>
It's always 'Look, it has that&#x2026;'. Never 'but in order to do that is has this'
</p>
</div>
</div>
</div>

<div id="outline-container-orgfd3f63f" class="outline-2">
<h2 id="orgfd3f63f"><span class="section-number-2">3</span> Beware: Easy is dangerous if it hides complexity!</h2>
<div class="outline-text-2" id="text-3">
<p>
Putting too much reliance on easy is not a good thing: You learn only by choosing the <i>unfamiliar</i>
</p>
</div>

<div id="outline-container-orge46d4b9" class="outline-3">
<h3 id="orge46d4b9"><span class="section-number-3">3.1</span> Easy things are often extremely complex, and chosing the easy-yet-complex thing is incidental complexity (i.e. it's your fault)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Complex things can be familiar, available and easy to use. Assignment, x=5, is very easy, but the implications of x=5 in the middle of a block of code can be profound.
</p>

<p>
A Library you chose to pull in with <code>pip install</code> is easy to get and easy to use - but it can hide an enourmous amount of complexity.
</p>

<p>
Any complexity that results from something you've decided to use is incidental (in the sense that it is <i>your fault</i>). 
</p>
</div>
</div>

<div id="outline-container-org33ffc44" class="outline-3">
<h3 id="org33ffc44"><span class="section-number-3">3.2</span> Choosing the easy-yet-complex makes you fast-at-first.</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Ignoring complexity will make you fast at first, and slow you down over the long term. Your artifact becomes a team member, the fungus slowly growing in the corner of the room, and over time it will dominant the decisions you can make
</p>
</div>
</div>
</div>

<div id="outline-container-orgef04723" class="outline-2">
<h2 id="orgef04723"><span class="section-number-2">4</span> Making things simple - simple constructs, abstractions, composability, data as data</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgfea491d" class="outline-3">
<h3 id="orgfea491d"><span class="section-number-3">4.1</span> Benefits of simplicity - Lego castles vs. knitted castles</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Picture two castles, one made out of lego, and one knitted from yarn.
</p>

<p>
The lego castle will be easier to reason about, and therefore change! More flexibilty - if you're not intertwined, you have architectural flexibility. Changing the policy, or moving subsystems
</p>
</div>
</div>

<div id="outline-container-org1bce3fa" class="outline-3">
<h3 id="org1bce3fa"><span class="section-number-3">4.2</span> Constructs: Complex -&gt; Simple</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>State/Objects -&gt; Values</li>
<li>Methods -&gt; Functions, namespaces</li>
<li>Syntax -&gt; Data</li>
<li>Inheritance, switch, matching -&gt; Polymorphism a la carte</li>
<li>variables -&gt; Managed Refs</li>
<li>Imperative loops, fold -&gt; set functions</li>
<li>Actors -&gt; Queues</li>
<li>ORM -&gt; Declarative data manipulation</li>
<li>conditions -&gt; tiles</li>
<li>inconsistency -&gt; consistency</li>
</ul>
</div>

<div id="outline-container-org051c687" class="outline-4">
<h4 id="org051c687"><span class="section-number-4">4.2.1</span> Table</h4>
<div class="outline-text-4" id="text-4-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Construct</th>
<th scope="col" class="org-left">Complects</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">State</td>
<td class="org-left">Everyhing it touches</td>
</tr>

<tr>
<td class="org-left">Objects</td>
<td class="org-left">State, identity, value</td>
</tr>

<tr>
<td class="org-left">Methods</td>
<td class="org-left">Function and state, namespaces</td>
</tr>

<tr>
<td class="org-left">Syntax</td>
<td class="org-left">Meaning, order</td>
</tr>

<tr>
<td class="org-left">Inheritance</td>
<td class="org-left">types</td>
</tr>

<tr>
<td class="org-left">switch/matching</td>
<td class="org-left">Multiple who/what pairs</td>
</tr>

<tr>
<td class="org-left">variables</td>
<td class="org-left">value, time</td>
</tr>

<tr>
<td class="org-left">loops/fold</td>
<td class="org-left">what/how</td>
</tr>

<tr>
<td class="org-left">actors</td>
<td class="org-left">what/who</td>
</tr>

<tr>
<td class="org-left">ORM</td>
<td class="org-left">OMG</td>
</tr>

<tr>
<td class="org-left">Conditionals</td>
<td class="org-left">why, rest of the program</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Construct</th>
<th scope="col" class="org-left">Got by</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Values</td>
<td class="org-left">final, persistent collections</td>
</tr>

<tr>
<td class="org-left">Functions</td>
<td class="org-left">stateless methods</td>
</tr>

<tr>
<td class="org-left">namespaces</td>
<td class="org-left">language support</td>
</tr>

<tr>
<td class="org-left">data</td>
<td class="org-left">maps, arrays, sets, xml, json</td>
</tr>

<tr>
<td class="org-left">polymorphism a la carte</td>
<td class="org-left">protocols, type classes</td>
</tr>

<tr>
<td class="org-left">managed refs</td>
<td class="org-left">clojure/haskell refs</td>
</tr>

<tr>
<td class="org-left">set functions</td>
<td class="org-left">libraries</td>
</tr>

<tr>
<td class="org-left">queues</td>
<td class="org-left">libraries</td>
</tr>

<tr>
<td class="org-left">declarative data manipulation</td>
<td class="org-left">SQL/LINQ/Datalog</td>
</tr>

<tr>
<td class="org-left">Rules</td>
<td class="org-left">Libraries, prolog</td>
</tr>

<tr>
<td class="org-left">consistency</td>
<td class="org-left">Transactions/values</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgefa16c1" class="outline-3">
<h3 id="orgefa16c1"><span class="section-number-3">4.3</span> Abstraction for simplicity - draw away the complexity</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Abstract means to draw away
</p>

<p>
There are maybe dangers from overabstracting (IFactoryResourceManager)
</p>

<p>
Abstracting to simplify is different from abstracting as hiding <i>complexity</i>. 
</p>

<p>
I don't know, I don't want to know. I want to be able to use your thing without knowing it
</p>
</div>
</div>

<div id="outline-container-org8007443" class="outline-3">
<h3 id="org8007443"><span class="section-number-3">4.4</span> Composability (not physical separation)</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Compose - to place together. Like legos. Composing simple components leads to robust software
</p>

<p>
OK, we know its not that straight forward. Modularity, just having two pieces of code sitting in their own modules (physically separated), they can still be deeply completed with eachother. Physical separation is a consequence of simplicity, not a guaranteed result of it.
</p>
</div>
</div>

<div id="outline-container-org9aef35c" class="outline-3">
<h3 id="org9aef35c"><span class="section-number-3">4.5</span> State is NEVER simple.</h3>
<div class="outline-text-3" id="text-4-5">
<p>
There is no way to uncomplect. It inherantly complects value and time. It complects everything it touches!
</p>

<p>
Be really scared of it. Label it. Make it explicit. Quarantine it on it's own
</p>

<p>
Your language can help you by having explicit refs/vars that compose value and time, i.e. make them distinct. Doesn't decomplect it to.
</p>
</div>
</div>

<div id="outline-container-org7013b70" class="outline-3">
<h3 id="org7013b70"><span class="section-number-3">4.6</span> Environmental complexity - we can't do anything about it</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Resources, CPU, memory
</p>

<p>
No good way to solve without introducing inefficiency!
</p>

<p>
Individual policies don't compose well - individual decisions don't combine to make good outcomes
</p>
</div>
</div>

<div id="outline-container-org98f0f58" class="outline-3">
<h3 id="org98f0f58"><span class="section-number-3">4.7</span> Example 2: Lists and Order (complecting the thing with it's neighbour)</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Every time you have a list you need to ask: Does order matter?
</p>

<p>
If I have <code>[depth width height]</code> &lt;- I'm going to forget the order!
</p>

<p>
Use sets, because they advertise that they are orderless
</p>

<p>
Why care about order? Complects each thing with the next, infects usage points, inhibit change. <code>[name email] -&gt; [name phone email]</code> is breaking!
</p>

<p>
Order is Baked into a ton of things!
</p>
<ul class="org-ul">
<li>Positional args -&gt; named args, map</li>
<li>Syntax -&gt; data</li>
<li>product types -&gt; associative records</li>
<li>imperative programs -&gt; declarative programs</li>
<li>prolog -&gt; datalog</li>
<li>call chains -&gt; queues</li>
<li>xml -&gt; JSON, EDN</li>
</ul>

<p>
(not saying don't use them - just be aware you are introducing complexity, be aware of the trade offs)
</p>

<p>
MAPS! USE MAPS! Make them powerful, make them idiomatic.
</p>
</div>
</div>

<div id="outline-container-org27bab5a" class="outline-3">
<h3 id="org27bab5a"><span class="section-number-3">4.8</span> Example 3: Data/Information is simple</h3>
<div class="outline-text-3" id="text-4-8">
<p>
There isn't a problem with information. Information is simple. But we make it a problem! We hide it behind a micro language - a class. You make a Box class and you have to invent a whole language to manipulate boxes.
</p>

<p>
Start representing data as data
</p>

<p>
When we use classes we think we are encapsulating. Encapsulation is about hiding implementation detail. But information doesn't have implementation, it's just data. There is no innards of information. You added it. Why?
</p>

<p>
The information <i>will</i> eventually have representation - you don't get around that by wrapping it in a class, at some point someone is going to want to see the information a class contains.
</p>

<p>
The litmus test - can you move it?
</p>

<p>
Subsystems must have
</p>
<ul class="org-ul">
<li>well defined boundaries</li>
<li>absstracted operaitnal interface (verbs)</li>
<li>general error handling (checked exceptions are a terrible terrible idea)</li>
<li>take/return data (not IPersonInfo). Do this inside and outside systems</li>
</ul>
</div>
</div>

<div id="outline-container-org733c9e7" class="outline-3">
<h3 id="org733c9e7"><span class="section-number-3">4.9</span> Simplify during analysis, modelling, waaaay before you implement</h3>
</div>
</div>
<div id="outline-container-org91c94a9" class="outline-2">
<h2 id="org91c94a9"><span class="section-number-2">5</span> Simplicity is a choice</h2>
<div class="outline-text-2" id="text-5">
<p>
Nothing manfactures simplicity. It's a decision making process, and you have to do it over and over again, get better at it. Develop 'entanglement' intuition
</p>

<p>
Don't overestimate your reliability tools: they don't check for simplicity
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Joe</p>
<p class="date">Created: 2020-05-10 Sun 15:47</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
