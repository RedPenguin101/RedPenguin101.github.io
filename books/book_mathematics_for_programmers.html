<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mathematics for Programmers</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mathematics for Programmers</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#parts">Parts</a></li>
<li><a href="#part-1-vectors-and-linear-algebra">Part 1: Vectors and Linear Algebra</a><ul>
<li><a href="#chapter-2-2d-vectors">Chapter 2: 2d vectors</a><ul>
<li><a href="#arithmetic">Arithmetic</a></li>
<li><a href="#trigonometry-and-polar-coordinates">Trigonometry and Polar coordinates</a></li>
<li><a href="#transformation-of-vector-collections">Transformation of vector collections</a></li>
</ul></li>
<li><a href="#d-vectors">3d vectors</a><ul>
<li><a href="#arithmetic-1">Arithmetic</a></li>
<li><a href="#dot-products">Dot products</a></li>
<li><a href="#cross-product">Cross Product</a></li>
<li><a href="#projecting-3d-shapes-onto-a-2d-plane">Projecting 3d shapes onto a 2d plane</a></li>
</ul></li>
<li><a href="#linear-transformations">Linear transformations</a></li>
<li><a href="#computing-transformations-with-matrices">Computing transformations with matrices</a><ul>
<li><a href="#matrix-.-vector-applying-linear-transformation">Matrix . Vector: Applying linear transformation</a></li>
<li><a href="#matrix-.-matrix-composition-of-linear-transformations">Matrix . Matrix: Composition of linear transformations</a></li>
<li><a href="#projection-as-a-linear-map-from-3d-to-2d">Projection as a linear map from 3d to 2d</a></li>
<li><a href="#translating-vectors-with-matrices">Translating vectors with matrices</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="parts">Parts</h1>
<ul>
<li>Vectors and linear algebra:
<ul>
<li>2d</li>
<li>3d</li>
<li>linear transformations</li>
<li>Matrices</li>
<li>Systems of linear equations</li>
</ul></li>
<li>Calculus
<ul>
<li>Rates of change</li>
<li>Motion simulation</li>
<li>Symbolic expressions</li>
<li>Force simulation</li>
<li>Physical system optimization</li>
<li>Fourier series</li>
</ul></li>
<li>Machine Learning
<ul>
<li>Fitting</li>
<li>Logistic regression</li>
<li>Neural networks</li>
</ul></li>
</ul>
<h1 id="part-1-vectors-and-linear-algebra">Part 1: Vectors and Linear Algebra</h1>
<ul>
<li><em>Linear algebra</em> deals with computations on multidimensional data.</li>
<li>A <em>vector</em> is a point in multidimensional space.</li>
<li>A <em>linear transformation</em> is an <code>f :: v -&gt; v</code> which preserves geometry. They can be represented as a <em>matrix</em>.</li>
<li>A <em>system of linear equations</em> tells us where dimensional bodies intersect in a vector space</li>
</ul>
<h2 id="chapter-2-2d-vectors">Chapter 2: 2d vectors</h2>
<ul>
<li>A 2d space is a <em>plane</em></li>
<li>The reference point of a plane is the <em>origin</em></li>
</ul>
<p>A 2d vector can be thought of as a point on the plane, or as an ‘arrow’ starting at the origin.</p>
<h3 id="arithmetic">Arithmetic</h3>
<p>Vector addition is pairwise. Vector addition is a <em>translation</em> on a 2d plane. You can ‘shift’ drawings around a canvas using vector addition.</p>
<p>The length of a line described by a vector (or distance of point from origin) is obtained by the Pythagorean theorem.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb1-1" title="1">(<span class="bu">defn</span><span class="fu"> vector-length </span>[[x y]]</a>
<a class="sourceLine" id="cb1-2" title="2">  (Math/sqrt (<span class="kw">+</span> (square x) (square y))))</a></code></pre></div>
<p>Scalar multiplication is <code>* :: s, v -&gt; v</code>, where <code>s</code> is a real number. The <em>opposite</em> vector to v is <code>-1 * v</code>.</p>
<p>Scalar multiplication <em>rescales</em> vectors on a 2d plane. That is, you can make images bigger or smaller on a canvas.</p>
<p>The <em>displacement</em> of two vectors <code>v</code> and <code>w</code> is a description of the line connecting them. It is obtained by <code>v-w</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb2-1" title="1">(<span class="bu">defn</span><span class="fu"> v+ </span>[&amp; vs] (<span class="kw">apply</span> <span class="kw">map</span> <span class="kw">+</span> vs))</a>
<a class="sourceLine" id="cb2-2" title="2">(<span class="bu">defn</span><span class="fu"> v* </span>[s v] (<span class="kw">map</span> #(<span class="kw">*</span> s <span class="va">%</span>) v))</a>
<a class="sourceLine" id="cb2-3" title="3">(<span class="bu">defn</span><span class="fu"> v- </span>[v1 v2] (v+ v1 (v* <span class="dv">-1</span> v2)))</a></code></pre></div>
<h3 id="trigonometry-and-polar-coordinates">Trigonometry and Polar coordinates</h3>
<p>If you know the <em>length</em> of a vector, and its <em>direction</em> (angle relative to axis) you can infer the coordinates. Put another way, the length (<code>r</code>) and angle (<code>a</code>) of a vector is an alternative and equivalent description of a vector: <code>[x,y] -&gt; [r,a]</code>. The first method is called the <em>Cartesian Coordinate</em> system, the second is the <em>Polar Coordinate</em> system.</p>
<p>Given an angle <code>a</code>, the coordinates of vectors along the line drawn to that angle will have a constant ratio. This ratio is called the <em>tangent</em> of the angle. <code>tan(a) = x/y</code></p>
<p>The <em>sine</em> and <em>cosine</em>, given an angle <code>a</code>, give the vertical and horizontal distance covered relative to the length of the vector. <code>sin(a) = y/r</code>, <code>cos(a) = x/r</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb3-1" title="1">(<span class="bu">defn</span><span class="fu"> polar-&gt;cartesian </span>[[r a]]</a>
<a class="sourceLine" id="cb3-2" title="2">  [(<span class="kw">*</span> r (Math/cos a)) (<span class="kw">*</span> r (Math/sin a))])</a></code></pre></div>
<p>The <em>arcsine</em>, <em>arccosine</em> and <em>arctangent</em> are the <em>inverse</em> of the trigonomic functions. That is, they translate from ratios of distances to angles. However, there are some gotchas here, and most programming languages provide an <code>atan2</code> (2-argument arctangent) function, which given an <em>x</em> and <em>y</em> coordinate will calculate the angle.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb4-1" title="1">(<span class="bu">defn</span><span class="fu"> cartesian-&gt;polar </span>[[x y]]</a>
<a class="sourceLine" id="cb4-2" title="2">  [(vector-length [x y]) (Math/atan2 y x)])</a></code></pre></div>
<p>Translations are easier with Cartesian, but rotation is easier with Polar. The rotation operation is <code>rotate :: angle, vector -&gt; vector</code>. When stated in polar coordinates, rotation is simply the addition of the angle parameter to the angle element of the polar-vector.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb5-1" title="1">(<span class="bu">defn</span><span class="fu"> vector-rotate </span>[a v]</a>
<a class="sourceLine" id="cb5-2" title="2">  (polar-&gt;cartesian (v+ [<span class="dv">0</span> a] (cartesian-&gt;polar v))))</a></code></pre></div>
<h3 id="transformation-of-vector-collections">Transformation of vector collections</h3>
<p>The three operations (translate with addition, rescale with multiplication, and rotate with rotation) can easily be extended to vector sets:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb6-1" title="1">(<span class="bu">defn</span><span class="fu"> xform-vectors </span>[xform]</a>
<a class="sourceLine" id="cb6-2" title="2">  (<span class="kw">fn</span> [vs x] (<span class="kw">map</span> #(xform x <span class="va">%</span>) vs)))</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4">(<span class="bu">def</span><span class="fu"> translate </span>(xform-vectors v+))</a>
<a class="sourceLine" id="cb6-5" title="5">(<span class="bu">def</span><span class="fu"> rescale   </span>(xform-vectors v*))</a>
<a class="sourceLine" id="cb6-6" title="6">(<span class="bu">def</span><span class="fu"> rotate    </span>(xform-vectors vector-rotate))</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">(<span class="kw">-&gt;</span> dino-vectors</a>
<a class="sourceLine" id="cb6-9" title="9">    (rotate (<span class="kw">*</span> <span class="dv">5</span> (<span class="kw">/</span> Math/PI <span class="dv">3</span>)))</a>
<a class="sourceLine" id="cb6-10" title="10">    (translate [<span class="dv">8</span> <span class="dv">8</span>]))</a></code></pre></div>
<h2 id="d-vectors">3d vectors</h2>
<p>2d vectors can be described as <code>[x, y]</code>. 3d vectors can be described with <code>[x, y, z]</code></p>
<h3 id="arithmetic-1">Arithmetic</h3>
<p>Arithmetic in three (or more) directions is very similar to two dimensions. We therefore need only to generalize our functions from the previous section.</p>
<p>Our addition and scalar multiplication functions don’t need to be changed to account for the 3rd dimension:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb7-1" title="1">(<span class="bu">defn</span><span class="fu"> v+ </span>[&amp; vs] (<span class="kw">apply</span> <span class="kw">map</span> <span class="kw">+</span> vs))</a>
<a class="sourceLine" id="cb7-2" title="2">(<span class="bu">defn</span><span class="fu"> v* </span>[s v]  (<span class="kw">map</span> #(<span class="kw">*</span> s <span class="va">%</span>) v))</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4">(v+ [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]) <span class="co">; (5 7 9)</span></a>
<a class="sourceLine" id="cb7-5" title="5">(v* <span class="dv">10</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">; (10 20 30)</span></a></code></pre></div>
<p>To calculate line length of <code>x,y,z</code>, we can think of the problem as being decomposed into two right angle triangles, the first in the <code>x,y</code> plane, and the second adding in the <code>z</code> plane.</p>
<p>The first will have length <code>a</code>, and will be calculated as before: <code>a = sqrt(x^2 + y^2)</code>. The second will be <code>b = sqrt(z^2 + a^2)</code>. This expands to</p>
<pre><code>b = sqrt(z^2 + (sqrt(x^2 + y^2))^2)
b = sqrt(z^2 + x^2 + y^2)</code></pre>
<p>Our function for <code>vector-length</code> will need to be generalized to handle higher dimensions.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb9-1" title="1">(<span class="bu">defn</span><span class="fu"> square </span>[x] (<span class="kw">*</span> x x))</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3">(<span class="bu">defn</span><span class="fu"> vector-length </span>[v]</a>
<a class="sourceLine" id="cb9-4" title="4">  (Math/sqrt (<span class="kw">apply</span> <span class="kw">+</span> (<span class="kw">map</span> square v))))</a></code></pre></div>
<h3 id="dot-products">Dot products</h3>
<p>There are two ways to multiply vectors together. The first is the <code>dot-product :: v1, v2 -&gt; s</code> (aka <em>inner product</em>), where s is a scalar. The second is the <code>cross-product :: v1, v2 -&gt; v3</code>. Each can help us reason about vectors in 3d.</p>
<p>You can think of the dot-product as representing <em>alignment</em> of two vectors. A positive dot product means positive alignment: they are pointing in around the same direction. Negative means the opposite. A dot-product of 0 means the vectors are <em>perpendicular</em>. This is very useful because otherwise you would need trigonometry to calculate the relative angle of vectors.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb10-1" title="1">(<span class="bu">defn</span><span class="fu"> dot-product </span>[v1 v2]</a>
<a class="sourceLine" id="cb10-2" title="2">   (<span class="kw">apply</span> <span class="kw">+</span> (<span class="kw">map</span> <span class="kw">*</span> v1 v2)))</a></code></pre></div>
<p>Some properties of dot-products:</p>
<p>Vectors lying on different axes are perpendicular (e.g. <code>[0 3 0], [0 0 -5]</code>)</p>
<pre><code>av dot w = v dot aw

a[x y] dot [n m]
= [ax ay] dot [n m]
= axn + aym
= [x y] dot [an am]
= [x y] dot a[n m]</code></pre>
<p>The maximum value of the dot product is the product of the length of the vectors. The minimum value is the negative of the product of lengths. Thus if <code>v . w = len(v) * len(w)</code>, v and w are perfectly aligned, and if <code>v . w = -(len(v) * len(w))</code> then v and w are opposite.</p>
<p>In other words, the dot-product divided by the product of lengths gives the angle between two vectors: 1 means 0, -1 means 180 degrees, 0 means 90 degrees. This, you might notice, is very similar to the cosine:</p>
<pre><code>cos(90) = 0
cos(0) = 1
cos(180) = -1</code></pre>
<p>In other words: <code>cos(a) = u.v / len(u)*len(v)</code>. By applying <code>acos</code> we use the dot product to calculate angles between vectors, <code>a = acos((u.v)/(len(u)*len(v)))</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb13-1" title="1">(<span class="bu">defn</span><span class="fu"> normalized-dot </span>[v1 v2]</a>
<a class="sourceLine" id="cb13-2" title="2">  (<span class="kw">/</span> (dot-product v1 v2)</a>
<a class="sourceLine" id="cb13-3" title="3">     (<span class="kw">*</span> (vector-length v1) (vector-length v2))))</a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">(<span class="bu">defn</span><span class="fu"> angle </span>[v1 v2]</a>
<a class="sourceLine" id="cb13-6" title="6">  (Math/acos (normalized-dot v1 v2))</a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8">(angle [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">; 0.47588224966041665</span></a>
<a class="sourceLine" id="cb13-9" title="9">(radian-&gt;degree (angle [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">2</span> <span class="dv">1</span>])) <span class="co">; 27.266044450732828</span></a></code></pre></div>
<h3 id="cross-product">Cross Product</h3>
<p>The formula for a 3d cross product is simple enough</p>
<pre><code>u x v = (uy vz - uz vy, uz vx - ux vz, ux vy - uy vx)</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb15-1" title="1">(<span class="bu">defn</span><span class="fu"> cross-product </span>[[ux uy uz] [vx vy vz]]</a>
<a class="sourceLine" id="cb15-2" title="2">  [(<span class="kw">-</span> (<span class="kw">*</span> uy vz) (<span class="kw">*</span> uz vy))</a>
<a class="sourceLine" id="cb15-3" title="3">   (<span class="kw">-</span> (<span class="kw">*</span> uz vx) (<span class="kw">*</span> ux vz))</a>
<a class="sourceLine" id="cb15-4" title="4">   (<span class="kw">-</span> (<span class="kw">*</span> ux vy) (<span class="kw">*</span> uy vx))])</a></code></pre></div>
<p>The geometric description, what the cross product <em>means</em>, is trickier, and will take some preliminary work.</p>
<p>First, direction. The cross product of two 3d vectors returns a 3d vector that is <em>perpendicular</em> two the two input vectors. (Perpendicular according to a <em>right hand rule</em> orientation.)</p>
<p>The length of the cross product tells us something like how perpendicular the two <em>input</em> vectors are to eachother. Specifically, it describes the area of the parallelogram with sides u and v.</p>
<h3 id="projecting-3d-shapes-onto-a-2d-plane">Projecting 3d shapes onto a 2d plane</h3>
<p>First, we must choose what direction we are observing from, by defining vectors that are ‘up’ <code>v-up</code> and ‘right’ <code>v-right</code> from our perspective.</p>
<p>We can then extract a <em>component</em> from any vector, relative to a direction vector with <code>dot-product(v, dir)/len(dir)</code>. Our projection function is therefore simply <code>[component(v, v-up), component(v, v-right)]</code></p>
<p>This will suffice to render the shape, but without distinguishing the faces of the shape with color, it will be hard for us to tell what it actually look like.</p>
<p>If we define a light source vector <code>v-light</code>, then the amount of light on the face of a shape (represented by a vector that is <em>normal</em> to the face) will be the alignment (i.e. dot-product) of that vector with <code>v-light</code>.</p>
<p>The normal vector of a face described by 3 vectors <em>v1, v2, v2</em> is</p>
<pre><code>n-vec = (v2-v1) x (v3-v1)</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb17-1" title="1">(<span class="bu">defn</span><span class="fu"> normal </span>[[v1 v2 v3]]</a>
<a class="sourceLine" id="cb17-2" title="2">  (cross-product (v- v2 v1) (v- v3 v1)))</a></code></pre></div>
<p>A final helper we will use is <code>unit</code>, which normalizes the vector to an overall length of 1.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb18-1" title="1">(<span class="bu">defn</span><span class="fu"> unit </span>[v] (v* (<span class="kw">/</span> <span class="dv">1</span> (vector-length v)) v))</a></code></pre></div>
<p>Bringing all this together, we want a function that translates a 3d-shape to a description of a 2 dimensional projection, including appropriate shading.</p>
<pre><code>project-shape :: 3d-polygon, v-up, v-right, v-light -&gt; 2d-shapes</code></pre>
<p>A 3d polygon is a sequence of 3 3-d vectors describing the triangular face of a 3d shape. <code>[v1 v2 v3]</code></p>
<p>A 2d shape is a sequence of three 2d vectors (describing a triangle) with a number describing it’s alignment (in 3d) to the light source.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb20-1" title="1">(<span class="bu">defn</span><span class="fu"> project-2d </span>[v, v-up, v-right]</a>
<a class="sourceLine" id="cb20-2" title="2">  [(component v v-up) (component v v-right)])</a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4">(<span class="bu">defn</span><span class="fu"> project-face </span>[face v-up v-right v-light]</a>
<a class="sourceLine" id="cb20-5" title="5">  (<span class="kw">when</span> (<span class="kw">&gt;</span> (<span class="kw">last</span> (unit (normal face))) <span class="dv">0</span>) </a>
<a class="sourceLine" id="cb20-6" title="6">    {<span class="at">:vertices</span>    (<span class="kw">map</span> #(project-2d <span class="va">%</span> v-up v-right) face)</a>
<a class="sourceLine" id="cb20-7" title="7">     <span class="at">:light-align</span> (normalized-dot (normal face) v-light)}))</a></code></pre></div>
<p>This returns a ‘shape’, comprised of the 2d vertices of the shape and its alignment to the light source. The <code>when</code> statement here filters out all faces whose z-component of the normal is less than zero - i.e. is facing downwards and is therefore not visible from the ‘overhead’ perspective we will start by using. This will be insufficient later, but for now is fine.</p>
<p>All that’s necessary now is to render the triangles using a drawing library, here <a href="https://github.com/Clojure2D/clojure2d">Clojure2D</a>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb21-1" title="1">(<span class="bu">defn</span><span class="fu"> color </span>[light-align]</a>
<a class="sourceLine" id="cb21-2" title="2">  (col/color <span class="at">:blue</span> (<span class="kw">+</span> <span class="dv">20</span> (<span class="kw">*</span> (<span class="kw">-</span> <span class="dv">1</span> light-align) <span class="dv">235</span>))))</a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4">(<span class="bu">defn</span><span class="fu"> s </span>[p] (<span class="kw">+</span> <span class="dv">500</span> (<span class="kw">*</span> <span class="dv">500</span> p)))</a>
<a class="sourceLine" id="cb21-5" title="5">(<span class="bu">defn</span><span class="fu"> flip-y </span>[v] (<span class="kw">update</span> v <span class="dv">1</span> <span class="kw">*</span> <span class="dv">-1</span>))</a>
<a class="sourceLine" id="cb21-6" title="6"></a>
<a class="sourceLine" id="cb21-7" title="7">(<span class="bu">defn</span><span class="fu"> draw-triangle </span>[canvas {<span class="at">:keys</span> [vertices light-align]}]</a>
<a class="sourceLine" id="cb21-8" title="8">  (c2d/with-canvas [c canvas]</a>
<a class="sourceLine" id="cb21-9" title="9">    (c2d/set-color c (color light-align))</a>
<a class="sourceLine" id="cb21-10" title="10">    (<span class="kw">let</span> [[[x1 y1] [x2 y2] [x3 y3]] (<span class="kw">map</span> flip-y vertices)]</a>
<a class="sourceLine" id="cb21-11" title="11">      (c2d/triangle c (s x1) (s y1) (s x2)</a>
<a class="sourceLine" id="cb21-12" title="12">                    (s y2) (s x3) (s y3)))))</a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14">(<span class="bu">defn</span><span class="fu"> render-triangles </span>[triangles]</a>
<a class="sourceLine" id="cb21-15" title="15">  (<span class="kw">let</span> [canvas (c2d/canvas <span class="dv">1000</span> <span class="dv">1000</span>)]</a>
<a class="sourceLine" id="cb21-16" title="16">    (<span class="kw">doseq</span> [t triangles] (draw-triangle canvas t))</a>
<a class="sourceLine" id="cb21-17" title="17">    (c2d/show-window canvas <span class="st">&quot;Drawing&quot;</span>)))</a></code></pre></div>
<p>TODO: * Add pictures * Write stuff about interpretting up, right, light vectors * filter faces that are not facing the <em>camera</em> * Better shading - alpha isn’t correct. Include better use of negative light-aligns * Better implementation of camera? Don’t really need 2 vectors surely. Something to do with view stretching? * Tidy up code and better explain component, unit, etc. * Axis label</p>
<h2 id="linear-transformations">Linear transformations</h2>
<p>A Linear Transfomation is a vector transformation <em>T</em> that preserves vector addition and scalar multiplication. That is, for any input vectors <em>u</em> and <em>v</em>, <code>T(u)+T(v)=T(u+v)</code>, and <code>T(sv)=sT(v)</code>. The transformation <code>[x^2, y^2]</code>, for example, is not a linear transformation. Translations are <em>not</em> (surprisingly). Scaling, reflection, projection, shearing, rotation all are.</p>
<p>A <em>linear combination</em> of a collection of vectors is a sum of scalar multiples of them. For example: <em>3u-2v</em>. Since these are linear transformations, addition and scalar multiplication are preserved.</p>
<pre><code>T(s1v1+s2v2+...+snvn)=s1T(v1)+s2T(v2)+...+snT(vn)</code></pre>
<p>The combination <em>0.5u+0.5v</em> is the midpoint of a line connecting two points <em>u</em> and <em>v</em>. In fact any <em>au+(1-a)v</em> (where <em>a&lt;=1</em>) is on the line connecting two points.</p>
<p>Any vector can be decomposed into a linear combination of dimensional units. <code>[4,3,5]</code> can be describes as the linear combination <code>4[1 0 0]+3[0 1 0]+5[0 0 1]</code>. These dimensional units are called the <em>standard basis</em> for n-dimensional spaces, and denoted <em>e1, e2, e3</em>. So the previous example can be written <code>4e1+3e2+5e3</code>. This is just a notation change, but it is a useful one for linear transformations.</p>
<h2 id="computing-transformations-with-matrices">Computing transformations with matrices</h2>
<p>Using the ideas from the last chapter: Let <em>a</em> be a linear transformation. All we know about <em>a</em> is that <code>a(e1)=[1 1 1], a(e2)=[1 0 -1], a(e3)=[0 1 1]</code> If <code>v=[-1,2,2]</code> what is <code>a(v)</code>?</p>
<p>We can write <em>v</em> as <code>-e1+2e2+2e3</code>.</p>
<pre><code>a(v)=a(-e1+2e2+2e3)=-a(e1)+2a(e2)+2a(e3)
= -[1 1 1]+2[1 0 -1]+2[0 1 1]=[1 1 -1]</code></pre>
<p>What we have done here is express a transformation as how it impacts the standard basis: <code>[1 0 -1],[0 1 1],[-1 2 2]</code>. <em>Any</em> transformation (in 3d) can be represented in this way, with these 9 numbers. We express this in a matrix for convenience (with the vectors ‘flipped’ vertical and set next to each other):</p>
<pre><code>[ 1 0 -1
  0 1  2
 -1 1  2]</code></pre>
<h3 id="matrix-.-vector-applying-linear-transformation">Matrix . Vector: Applying linear transformation</h3>
<p>If a linear transformation <em>T</em> can be represented as a matrix, then the application of the linear transformation <em>Tv</em> is obtained by multiplying the matrix by the vector <em>v</em>.</p>
<pre><code>[0 2  1  [ 3
 0 1  0   -2
 1 0 -1]   5]</code></pre>
<p>The calculation is done by applying the dot-product of the rows of the matrix to the vector:</p>
<pre><code>[0 2 1].[3 -2 5] = 1
[0 1 0].[3 -2 5] = -2
[1 0 -1].[3 -2 5] = -2</code></pre>
<p>(Note that <em>Bv != vB</em>. Matrix multiplication is non-commutative)</p>
<h3 id="matrix-.-matrix-composition-of-linear-transformations">Matrix . Matrix: Composition of linear transformations</h3>
<p>Let’s say you have 1000 vectors, and you want to apply the same 1000 transformations to every vector. This takes 1000000 calculations. However, if you can compose the 1000 linear transformations into <em>one</em> linear transformation (which by the properties of linear transformations we can), then we can apply the composition to the vector, and complete the task in 1001 calculations.</p>
<p>In other words, instead of <em>A(Bv)</em>, we want to do <em>(AB)v</em>. This, we can do. The above method of matrix multiplication extends for the second argument being a 3x3 matrix, just with 9 dot products, 3 for each ‘column’ of matrix <em>B</em>.</p>
<p>In general, a matrix that is <em>mxn</em> can be multiplied by a <em>pxq</em> matrix only when <em>n=p</em>. The resulting matrix is <em>nxq</em>.</p>
<h3 id="projection-as-a-linear-map-from-3d-to-2d">Projection as a linear map from 3d to 2d</h3>
<p>A <em>linear map</em> (sometimes linear function) is also an operation on vectors. Like a linear transformation it preserves vector sums and scalar multiplications. But, unlike a linear transformation, it <em>doesn’t</em> need to preserve dimensions.</p>
<p>If <em>v</em> is a 3d vector (i.e. <em>3x1</em> matrix), and <em>A</em> is a <em>2x3</em> matrix, the result of <em>Av</em> is a <em>2x1</em> matrix - or a 2d vector. We can use this to describe projection as a linear map.</p>
<p>Consider the rules we established before for projection.</p>
<pre><code>Given v-up u=[u1 u2 u3] and v-right r=[r1 r2 r3]

project2d of v=[v1 v2 v3]
= [(v.u)/len(u), (v.r)/len(r)]
= [v.(u/len(u)), v.(r/len(r))]</code></pre>
<p>Assuming u and r are already in normalized form (length=1) this can be expressed as matrix multiplication</p>
<pre><code>[u1 u2 u3  [v1    [[u1 u2 u3].[v1 v2 v3]
 r1 r2 r3]  v2  =  [r1 r2 r3].[v1 v2 v3]]
            v3]</code></pre>
<p>What’s more, transformation and projection can also be composed: <code>TP</code> is a <em>3x3</em> matrix multiplied by a <em>3x2</em> matrix, yielding a <em>3x2</em> matrix.</p>
<h3 id="translating-vectors-with-matrices">Translating vectors with matrices</h3>
<p>We noted earlier that translations (shifting points around a plane) are not linear transformations. Another way of saying this is that there is no 2d matrix that, when applied to a linear combination of vectors, will preserve addition and multiplication.</p>
<p>This is inconvenient because it means we can’t use our matrix method to do this.</p>
<p>There is a trick for doing translations in 2d: You can think of the 2d vectors as <em>3d</em> vectors, and then, magically, you _can</p>
</body>
</html>
