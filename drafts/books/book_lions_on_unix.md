# A Commentary on the Sixth Edition UNIX Operation System, by J Lions

## Notes while reading
### Preface

* UNIX is small: a nucleus of LT 9k LOC
* Teaching OS: Principles (hard!), building block (toy OS, doesn't give the complexity), Case study (this)

### 1. Intro
* Scope is the code that is permenantly resident in memory during operation
* With functions
  * initialization
  * process management
  * system calls
  * interrupt handling
  * IO operations
  * file management
* The rest is (broadly) 'utilities' - the shell, user-space programs etc. These are not in scope
* Organization: the code is divided into sections:
  * I: initialization and process management. All assembly is here
  * II: Interrupts, traps, syscalls, signals
  * III: Disk soperations
  * IV: Files and filesystems
  * V: "Character Special Files" - or other devices.

### 2. Fundamentals of the PDP11
* Talks about the processor, 16bit words, registers, PSW
* Processor has kernel and user 'modes', with kernel being more privileged and reserved for the OS.
* UNIX convention for registers: 
  * r0/1 are used as temporary accumulators during evaluation
  * r2/3/4 are used for local variables during execution. Usually the original values are stored after execution
  * r5 is used as the 'environment pointer': a pointer to the head of a chain of procedure activation records stored in the current stack (don't know what this means)
* Instruction set: a long list which I won't go into here.
* Addressing mode: again, won't go into here
* UNIX assembler is a two-pass assembler. Grammar rules are mentioned here
* Direct addressing 64k bytes (32k words). But larger PDP11's have up to 256KB RAM, which need 18bits (2^18=262,144) to address. The PDP has a mechanism called the Memory Management Unit (MMU) to convert 16bit 'virtual' addresses into 18bit 'physical' ones.
* The MMU does this with segmentation registers.
  * The segment registers are 8 pairs of `[PAR PDR]` - a page address register and a page description register
  * A virtual address 'belongs' to a page. 
  * When given a virtual (16bit) address, you get to the physical address by adding the relative address within the page to the PAR.
  * I don't get it.
  * The PDR defines (among other things) access modes: whether a page is RO, RW
  * The MMU has two status registers: SR0 (abort flags) and SR2 (on requests for memory, the 16bit virtual address is put here)
* The MMU is disabled when the system starts (and the processor) is kernel mode. Where the machine has more than 64KB RAM, the virtual to physical address mappings are not one to one though:
  * 00 - 157777 are mapped to the corresponding physical locations
  * 0160000 to 0177777 are mapped to the highest physical memory addressed - e.g on a 256k machine to 0760000 to 0777777

### 3. Reading C - examples

Won't say much here except that the source code is in _old_ C.

```c
bcopy (from, to, count)
int *from, *to;
{
 register *a, *b, c;
 a = from;
 b = to;
 c = count;
 do
   *b++ = *a++;
 while (--cc);
}
```

In more modern C (i.e. from the 80's) it would be like this

```c
void my_bcopy(int* from, int* to, int count) {
  do
    *to++ = *from++;
  while (--count);
  return;
}
```

### 4. Overview
* Presenting the wood before getting into the trees
* 44 files:
  * 2 in assembly
  * 28 c files
  * 14 c header files (i.e. Not intended for independent compilations)
* Some file reorganization has been done for teachability
* global variable declaration (with a few exceptions) is in the header files
* Section I: Header files
  * `param.h`: no variable defs, but many constants including sigcodes. Also 3 structs: `int` (16bits), integer in bytes (2x `char`, lo and hi bytes), integer sequence
  * `systm.h`: all declarations. Also structs for `callo` ('callout', used by clock interrupts) and `mount` structures
  * `seg.h` a few definitions. Very short
  * `proc.h`: the important `proc` structure definition, which contains all information about a running process, and declaration of the `proc[NPROC]` variable. Also definition of stat and flag codes.
  * `user.h`: the _very_ important (and large) `user` structure, and declaration of the unhelpfully names `u`. Plus error codes.
* Section I.2: Assembly
  * `low.s` contains code for initializing the 'low address' part of main memory. It is a per-install file generated by the `mkconf` utility
  * `m40.s` a looong file with PDP11 routines that can't be implemented in C.
* Section I.3: Others
  * `main.c`: contains `main()` and a couple of functions `estabur` and `sureg` for setting up the seg registers.
  * `slp.c`: Process management functions. LONG
  * `prf.c`: functions for displaying messages, including `printf`
  * `malloc.c`: you know what this is
  *
