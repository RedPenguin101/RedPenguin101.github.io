# A The Annotated Sixth Edition UNIX Operation System
This post is a full, file by file annotation of the source code for the kernel of the UNIX operating system, sixth edition, for the PDP11. It's about 9,000 lines of code, mostly in C[^1], with some Assembly. It is for a large part based on [J Lion's](http://warsus.github.io/lions-/) commentary.

[^1]: Very _old_ C.

This post won't go into the detail of the PDP11 architecture, as the Lions book does. However, it does use its slightly re-organized version of the source code, since it means the narrative 'flows' a little better. These 'sections' are divided as follows:

* Section 1 contains mostly header files, as well as the only assembly files
* Section 2 deals with processor traps
* Section 3 contains most of the IO
* Section 4 is about files and the filesystem
* Section 5 deals with older devices, like paper tapes and line printers

## Section 1
Section 1 contains mostly header files.

### Param.h
This file contains many definitions for OS constants.

```c
/* fundamental constants: cannot be changed */
#define USIZE   16              /* size of user block (*64) */
#define NULL    0
#define NODEV   (-1)
#define ROOTINO 1               /* i number of all roots */
#define DIRSIZ  14              /* max characters per directory */

/* signals: dont change */
#define NSIG    20
#define         SIGHUP  1       /* hangup */
#define         SIGINT  2       /* interrupt (rubout) */
#define         SIGQIT  3       /* quit (FS) */
#define         SIGINS  4       /* illegal instruction */
#define         SIGTRC  5       /* trace or breakpoint */
#define         SIGIOT  6       /* iot */
#define         SIGEMT  7       /* emt */
#define         SIGFPT  8       /* floating exception */
#define         SIGKIL  9       /* kill */
#define         SIGBUS  10      /* bus error */
#define         SIGSEG  11      /* segmentation violation */
#define         SIGSYS  12      /* sys */
#define         SIGPIPE 13      /* end of pipe */

/* tunable variables */
#define NBUF    15              /* size of buffer cache */
#define NINODE  100             /* number of in core inodes */
#define NFILE   100             /* number of in core file structures */
#define NMOUNT  5               /* number of mountable file systems */
#define NEXEC   3               /* number of simultaneous exec's */
#define MAXMEM  (64*32)         /* max core per process 
                                                - first # is Kw */
#define SSIZE   20              /* initial stack size (*64 bytes) */
#define SINCR   20              /* increment of stack (*64 bytes) */
#define NOFILE  15              /* max open files per process */
#define CANBSIZ 256             /* max size of typewriter line */
#define CMAPSIZ 100             /* size of core allocation area */
#define SMAPSIZ 100             /* size of swap allocation area */
#define NCALL   20              /* max simultaneous time callouts */
#define NPROC   50              /* max number of processes */
#define NTEXT   40              /* max number of pure texts */
#define NCLIST  100             /* max total clist size */
#define HZ      60              /* Ticks/second of the clock */

/* priorities: probably should not be altered too much */
#define PSWP    -100
#define PINOD   -90
#define PRIBIO  -50
#define PPIPE   1
#define PWAIT   40
#define PSLEP   90
#define PUSER   100

/* Certain processor registers */
#define PS      0177776
#define KL      0177560
#define SW      0177570

```

Three simple structures are defined. Note the division of the 'word' into a lobyte and hibyte.

```c
struct {   int   integ;   };
struct {   char lobyte;   char hibyte;   };
struct {   int   r[];   };

```

### Systm.h
Contains declarations of variables.

```c
/* Random set of variables used by more than one routine. */
char    canonb[CANBSIZ];        /* buffer for erase and kill (#@) */
```

The coremap and swapmap are used in memory allocation. Though they are declared here as arrays of integers, they are interpreted as arrays of 'maps', consisting of two character pointers. See _malloc.c_ for details.

```c
int     coremap[CMAPSIZ];       /* space for core allocation */
int     swapmap[SMAPSIZ];       /* space for swap allocation */
```

```c
int     *rootdir;               /* pointer to inode of root directory */
int     cputype;                /* type of cpu =40, 45, or 70 */
int     execnt;                 /* number of processes in exec */
int     lbolt;                  /* time of day in 60th not in time */
int     time[2];                /* time in sec from 1970 */
int     tout[2];                /* time of day of next sleep */
int     mpid;                   /* generic for unique process id's */
char    runin;                  /* scheduling flag */
char    runout;                 /* scheduling flag */
char    runrun;                 /* scheduling flag */
char    curpri;                 /* more scheduling */
int     maxmem;                 /* actual max memory per process */
int     *lks;                   /* pointer to clock device */
int     rootdev;                /* dev of root see conf.c */
int     swapdev;                /* dev of swap see conf.c */
int     swplo;                  /* block number of swap space */
int     nswap;                  /* size of swap space */
int     updlock;                /* lock for sync */
int     rablock;                /* block to be read ahead */
char    regloc[];               /* locs. of saved user registers (trap.c) */
```

Two important data structures are defined. `callo` or 'callout', and `mount`. 'A mount' is a mounted file system, though I don't know what a 'superblock' or 'inode' is.

The callout structure is for a routine arranging to be called by the clock interrupt (clock.c) with a specified argument, within a specified amount of time. It is used, for example, to time tab delays on teletypes.

Note that each declaration is defined as an _array_ of the respective structures. `NCALL` is 20 and `NMOUNT` is 5.

```c
struct  callo
{
        int     c_time;         /* incremental time */
        int     c_arg;          /* argument to routine */
        int     (*c_func)();    /* routine */
} callout[NCALL];

struct  mount
{
        int     m_dev;          /* device mounted */
        int     *m_bufp;        /* pointer to superblock */
        int     *m_inodp;       /* pointer to mounted on inode */
} mount[NMOUNT];
```

### seg.h
More definitions, and one declaration: `ka6`, which is used as a pointer to segment registers.

```c
/* KT-11 addresses and bits */
#define UISD    0177600         /* first user I-space descriptor register */
#define UISA    0177640         /* first user I-space address register */
#define UDSA    0177660         /* first user D-space address register */
#define UBMAP   0170200         /* address to access 11/70 UNIBUS map */
#define RO      02              /* access abilities */
#define WO      04
#define RW      06
#define ED      010             /* extend direction */

int     *ka6;           /* 11/40 KISA6; 11/45 KDSA6 */
```

### proc.h

This file contains the declaration of the important `proc` structure. As above, the declaration is of an array of processes - 50 to be exact.

One structure allocated per active process. It contains all data needed about the process while the process may be swapped out. Other per process data (user.h) is swapped with the process.

```c
struct  proc
{
        char    p_stat;
        char    p_flag;
        char    p_pri;          /* priority, negative is high */
        char    p_sig;          /* signal number sent to this process */
        char    p_uid;          /* user id, used to direct tty signals */
        char    p_time;         /* resident time for scheduling */
        char    p_cpu;          /* cpu usage for scheduling */
        char    p_nice;         /* nice for scheduling */
        int     p_ttyp;         /* controlling tty */
        int     p_pid;          /* unique process id */
        int     p_ppid;         /* process id of parent */
        int     p_addr;         /* address of swappable image */
        int     p_size;         /* size of swappable image (*64 bytes) */
        int     p_wchan;        /* event process is awaiting */
        int     *p_textp;       /* pointer to text structure */

} proc[NPROC];

```

The possible values for the `p_stat` and `p_flag` elements are also defined in this file.

```c
/* stat codes */
#define SSLEEP  1               /* sleeping on high priority */
#define SWAIT   2               /* sleeping on low priority */
#define SRUN    3               /* running */
#define SIDL    4               /* intermediate state in process creation */
#define SZOMB   5               /* intermediate state in process termination */
#define SSTOP   6               /* process being traced */

/* flag codes */
#define SLOAD   01              /* in core */
#define SSYS    02              /* scheduling process */
#define SLOCK   04              /* process cannot be swapped */
#define SSWAP   010             /* process is being swapped out */
#define STRC    020             /* process is being traced */
#define SWTED   040             /* another tracing flag */
```

### user.h

Contains the vital `user` structure, of which there is a single instance, `u`. There is one user allocated per process. Contains all per process data that doesn't need to be referenced while the process is swapped. The user block is USIZE*64 bytes long; resides at virtual kernel loc 140000; contains the system stack per user; is cross referenced with the proc structure for the same process.

```c
struct user
{
        int     u_rsav[2];              /* save r5,r6 when exchanging stacks */
        int     u_fsav[25];             /* save fp registers */
                                        /* rsav and fsav must be first in structure */
        char    u_segflg;               /* flag for IO; user or kernel space */
        char    u_error;                /* return error code */
        char    u_uid;                  /* effective user id */
        char    u_gid;                  /* effective group id */
        char    u_ruid;                 /* real user id */
        char    u_rgid;                 /* real group id */
        int     u_procp;                /* pointer to proc structure */
        char    *u_base;                /* base address for IO */
        char    *u_count;               /* bytes remaining for IO */
        char    *u_offset[2];           /* offset in file for IO */
        int     *u_cdir;                /* pointer to inode of current directory */
        char    u_dbuf[DIRSIZ];         /* current pathname component */
        char    *u_dirp;                /* current pointer to inode */
        struct  {                       /* current directory entry */
                int     u_ino;
                char    u_name[DIRSIZ];
        } u_dent;
        int     *u_pdir;                /* inode of parent directory of dirp */
        int     u_uisa[16];             /* prototype of segmentation addresses */
        int     u_uisd[16];             /* prototype of segmentation descriptors */
        int     u_ofile[NOFILE];        /* pointers to file structures of open files */
        int     u_arg[5];               /* arguments to current system call */
        int     u_tsize;                /* text size (*64) */
        int     u_dsize;                /* data size (*64) */
        int     u_ssize;                /* stack size (*64) */
        int     u_sep;                  /* flag for I and D separation */
        int     u_qsav[2];              /* label variable for quits and interrupts */
        int     u_ssav[2];              /* label variable for swapping */
        int     u_signal[NSIG];         /* disposition of signals */
        int     u_utime;                /* this process user time */
        int     u_stime;                /* this process system time */
        int     u_cutime[2];            /* sum of childs' utimes */
        int     u_cstime[2];            /* sum of childs' stimes */
        int     *u_ar0;                 /* address of users saved R0 */
        int     u_prof[4];              /* profile arguments */
        char    u_intflg;               /* catch intr from sys */
                                        /* kernel stack per user
                                         * extends from u + USIZE*64
                                         * backward not to reach here
                                         */
} u;
```

There are errors codes which are the valid values for the `u_error` element.

```c
/* u_error codes */
#define EFAULT  106
#define EPERM   1
#define ENOENT  2
#define ESRCH   3
#define EINTR   4
#define EIO     5
#define ENXIO   6
#define E2BIG   7
#define ENOEXEC 8
#define EBADF   9
#define ECHILD  10
#define EAGAIN  11
#define ENOMEM  12
#define EACCES  13
#define ENOTBLK 15
#define EBUSY   16
#define EEXIST  17
#define EXDEV   18
#define ENODEV  19
#define ENOTDIR 20
#define EISDIR  21
#define EINVAL  22
#define ENFILE  23
#define EMFILE  24
#define ENOTTY  25
#define ETXTBSY 26
#define EFBIG   27
#define ENOSPC  28
#define ESPIPE  29
#define EROFS   30
#define EMLINK  31
#define EPIPE   32
```

### low.s and m40.s

The two assembly files. low.s contains information for initializing the 'low' address of main memory. This is a 'per machine' file, and is generated by the utility program `mkconf` in order to match the peripherals attached to a particular device. It is excluded for now

The second assembly file, m40.s. Contains functions which can't be implemented in c. It is _very_ long, so I'm going to skip it until I have something to actually say about it.

### main.c

```c
#include "../param.h"
#include "../user.h"
#include "../systm.h"
#include "../proc.h"
#include "../text.h"
#include "../inode.h"
#include "../seg.h"

#define CLOCK1  0177546
#define CLOCK2  0172540
```

`icode` is the octal bootstrap program executed in user mode to bring up the system.

```c
int     icode[]
{
        0104413,        /* sys exec; init; initp */
        0000014,
        0000010,
        0000777,        /* br . */
        0000014,        /* initp: init; 0 */
        0000000,
        0062457,        /* init: </etc/init\0> */
        0061564,
        0064457,
        0064556,
        0000164,
};

```

The main function contains the Initialization code. Called from m40.s or m45.s as soon as a stack and segmentation have been established. It has the Functions:
* clear and free user core
* find which clock is configured
* hand craft 0th process
* call all initialization routines
* fork
  * process 0 to schedule
  * process 1 execute bootstrap

panic: no clock -- neither clock responds loop at loc 6 in user mode -- /etc/init cannot be executed. */

```c

main()
{
        extern schar;
        register i, *p;

        /* zero and free all of core */
        updlock = 0;
        i = *ka6 + USIZE;
        UISD->r[0] = 077406;
        for(;;) {
                UISA->r[0] = i;
                if(fuibyte(0) < 0)
                        break;
                clearseg(i);
                maxmem++;
                mfree(coremap, 1, i);
                i++;
        }
        if(cputype == 70)
        for(i=0; i<62; i=+2) {
                UBMAP->r[i] = i<<12;
                UBMAP->r[i+1] = 0;
        }
        printf("mem = %l\n", maxmem*5/16);

        maxmem = min(maxmem, MAXMEM);
        mfree(swapmap, nswap, swplo);

        /* set up system process */
        proc[0].p_addr = *ka6;
        proc[0].p_size = USIZE;
        proc[0].p_stat = SRUN;
        proc[0].p_flag =| SLOAD|SSYS;
        u.u_procp = &proc[0];

        /* determine clock */
        UISA->r[7] = ka6[1]; /* io segment */
        UISD->r[7] = 077406;
        lks = CLOCK1;
        if(fuiword(lks) == -1) {
                lks = CLOCK2;
                if(fuiword(lks) == -1)
                        panic("no clock");
        }

        /* set up 'known' i-nodes */
        *lks = 0115;
        cinit();
        binit();
        iinit();
        rootdir = iget(rootdev, ROOTINO);
        rootdir->i_flag =& ~ILOCK;
        u.u_cdir = iget(rootdev, ROOTINO);
        u.u_cdir->i_flag =& ~ILOCK;

        /* make init process enter scheduling loop with system process */
        if(newproc()) {
                expand(USIZE+1);
                estabur(0, 1, 0, 0);
                copyout(icode, 0, sizeof icode);
                /* Return goes to loc. 0 of user init code just copied out. */
                return;
        }
        sched();
}

```

`estabur` sets up software prototype segmentation registers to implement the 3 pseudo text (`nt`),data (`nd`), and stack (`ns`) segment sizes passed as arguments. The argument `sep` specifies if the text and data+stack segments are to be separated. This is called in `main` as `estabur(0, 1, 0, 0)`

```c
estabur(nt, nd, ns, sep)
{
        register a, *ap, *dp;

        if(sep) {
                if(cputype == 40)
                        goto err;
                if(nseg(nt) > 8 || nseg(nd)+nseg(ns) > 8)
                        goto err;
        } else
                if(nseg(nt)+nseg(nd)+nseg(ns) > 8)
                        goto err;
        if(nt+nd+ns+USIZE > maxmem)
                goto err;
        a = 0;
        ap = &u.u_uisa[0];
        dp = &u.u_uisd[0];
        while(nt >= 128) {
                *dp++ = (127<<8) | RO;
                *ap++ = a;
                a =+ 128;
                nt =- 128;
        }
        if(nt) {
                *dp++ = ((nt-1)<<8) | RO;
                *ap++ = a;
        }
        if(sep)
        while(ap < &u.u_uisa[8]) {
                *ap++ = 0;
                *dp++ = 0;
        }
        a = USIZE;
        while(nd >= 128) {
                *dp++ = (127<<8) | RW;
                *ap++ = a;
                a =+ 128;
                nd =- 128;
        }
        if(nd) {
                *dp++ = ((nd-1)<<8) | RW;
                *ap++ = a;
                a =+ nd;
        }
        while(ap < &u.u_uisa[8]) {
                *dp++ = 0;
                *ap++ = 0;
        }
        if(sep)
        while(ap < &u.u_uisa[16]) {
                *dp++ = 0;
                *ap++ = 0;
        }
        a =+ ns;
        while(ns >= 128) {
                a =- 128;
                ns =- 128;
                *--dp = (127<<8) | RW;
                *--ap = a;
        }
        if(ns) {
                *--dp = ((128-ns)<<8) | RW | ED;
                *--ap = a-128;
        }
        if(!sep) {
                ap = &u.u_uisa[0];
                dp = &u.u_uisa[8];
                while(ap < &u.u_uisa[8])
                        *dp++ = *ap++;
                ap = &u.u_uisd[0];
                dp = &u.u_uisd[8];
                while(ap < &u.u_uisd[8])
                        *dp++ = *ap++;
        }
        sureg();
        return(0);

err:
        u.u_error = ENOMEM;
        return(-1);
}

```

Loads the user hardware segmentation registers from the software prototype. The software registers must have been setup prior by `estabur`, and in fact the procedure is called from that function.

```c
sureg()
{
        register *up, *rp, a;

        a = u.u_procp->p_addr;
        up = &u.u_uisa[16];
        rp = &UISA->r[16];
        if(cputype == 40) {
                up =- 8;
                rp =- 8;
        }
        while(rp > &UISA->r[0])
                *--rp = *--up + a;
        if((up=u.u_procp->p_textp) != NULL)
                a =- up->x_caddr;
        up = &u.u_uisd[16];
        rp = &UISD->r[16];
        if(cputype == 40) {
                up =- 8;
                rp =- 8;
        }
        while(rp > &UISD->r[0]) {
                *--rp = *--up;
                if((*rp & WO) == 0)
                        rp[(UISA-UISD)/2] =- a;
        }
}

```

Return the arg/128 rounded up.

```c
nseg(n)
{
        return((n+127)>>7);
}
```

### slp.c

```c
#include "../param.h"
#include "../user.h"
#include "../proc.h"
#include "../text.h"
#include "../systm.h"
#include "../file.h"
#include "../inode.h"
#include "../buf.h"
```

Create a new process-- the internal version of sys fork. It returns 1 in the new process. How this happens is rather hard to understand. The essential fact is that the new process is created in such a way that appears to have started executing in the same call to newproc as the parent; but in fact the code that runs is that of swtch. The subtle implication of the returned value of swtch (see above) is that this is the value that newproc's caller in the new process sees.

```c
newproc()
{
        int a1, a2;
        struct proc *p, *up;
        register struct proc *rpp;
        register *rip, n;

        p = NULL;
        /* First, just locate a slot for a process
         * and copy the useful info from this process into it.
         * The panic "cannot happen" because fork has already
         * checked for the existence of a slot. */
retry:
        mpid++;
        if(mpid < 0) {
                mpid = 0;
                goto retry;
        }
        for(rpp = &proc[0]; rpp < &proc[NPROC]; rpp++) {
                if(rpp->p_stat == NULL && p==NULL)
                        p = rpp;
                if (rpp->p_pid==mpid)
                        goto retry;
        }
        if ((rpp = p)==NULL)
                panic("no procs");

        /* make proc entry for new proc */
        rip = u.u_procp;
        up = rip;
        rpp->p_stat = SRUN;
        rpp->p_flag = SLOAD;
        rpp->p_uid = rip->p_uid;
        rpp->p_ttyp = rip->p_ttyp;
        rpp->p_nice = rip->p_nice;
        rpp->p_textp = rip->p_textp;
        rpp->p_pid = mpid;
        rpp->p_ppid = rip->p_pid;
        rpp->p_time = 0;

        /* make duplicate entries where needed */
        for(rip = &u.u_ofile[0]; rip < &u.u_ofile[NOFILE];)
                if((rpp = *rip++) != NULL)
                        rpp->f_count++;
        if((rpp=up->p_textp) != NULL) {
                rpp->x_count++;
                rpp->x_ccount++;
        }
        u.u_cdir->i_count++;

        /* Partially simulate the environment
         * of the new process so that when it is actually
         * created (by copying) it will look right. */
        savu(u.u_rsav);
        rpp = p;
        u.u_procp = rpp;
        rip = up;
        n = rip->p_size;
        a1 = rip->p_addr;
        rpp->p_size = n;
        a2 = malloc(coremap, n);

        /* If there is not enough core for the
         * new process, swap out the current process to generate the
         * copy. */
        if(a2 == NULL) {
                rip->p_stat = SIDL;
                rpp->p_addr = a1;
                savu(u.u_ssav);
                xswap(rpp, 0, 0);
                rpp->p_flag =| SSWAP;
                rip->p_stat = SRUN;
        } else {

        /* There is core, so just copy. */
                rpp->p_addr = a2;
                while(n--)
                        copyseg(a1++, a2++);
        }
        u.u_procp = rip;
        return(0);
}
```
#### sched
The main loop of the scheduling (swapping) process. The basic idea is:
1. see if anyone wants to be swapped in;
1. swap out processes until there is room;
1. swap him in;
1. repeat.

Although it is not remarkably evident, the basic synchronization here is on the runin flag, which is slept on and is set once per second by the clock routine. Core shuffling therefore takes place once per second.

**panic:** swap error -- IO error while swapping. This is the one panic that should be handled in a less drastic way. It's very hard.

```c
sched()
{
        struct proc *p1;
        register struct proc *rp;
        register a, n;

        /* find user to swap in
         * of users ready, select one out longest */

        goto loop;

sloop:
        runin++;
        sleep(&runin, PSWP);

loop:
        spl6();
        n = -1;
        for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
        if(rp->p_stat==SRUN && (rp->p_flag&SLOAD)==0 &&
            rp->p_time > n) {
                p1 = rp;
                n = rp->p_time;
        }
        if(n == -1) {
                runout++;
                sleep(&runout, PSWP);
                goto loop;
        }

        /* see if there is core for that process */

        spl0();
        rp = p1;
        a = rp->p_size;
        if((rp=rp->p_textp) != NULL)
                if(rp->x_ccount == 0)
                        a =+ rp->x_size;
        if((a=malloc(coremap, a)) != NULL)
                goto found2;

        /* none found, look around for easy core */

        spl6();
        for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
        if((rp->p_flag&(SSYS|SLOCK|SLOAD))==SLOAD &&
            (rp->p_stat == SWAIT || rp->p_stat==SSTOP))
                goto found1;

        /* no easy core, if this process is deserving,
         * look around for oldest process in core */

        if(n < 3)
                goto sloop;
        n = -1;
        for(rp = &proc[0]; rp < &proc[NPROC]; rp++)
        if((rp->p_flag&(SSYS|SLOCK|SLOAD))==SLOAD &&
           (rp->p_stat==SRUN || rp->p_stat==SSLEEP) &&
            rp->p_time > n) {
                p1 = rp;
                n = rp->p_time;
        }
        if(n < 2)
                goto sloop;
        rp = p1;

        /* swap user out */

found1:
        spl0();
        rp->p_flag =& ~SLOAD;
        xswap(rp, 1, 0);
        goto loop;

        /* swap user in */

found2:
        if((rp=p1->p_textp) != NULL) {
                if(rp->x_ccount == 0) {
                        if(swap(rp->x_daddr, a, rp->x_size, B_READ))
                                goto swaper;
                        rp->x_caddr = a;
                        a =+ rp->x_size;
                }
                rp->x_ccount++;
        }
        rp = p1;
        if(swap(rp->p_addr, a, rp->p_size, B_READ))
                goto swaper;
        mfree(swapmap, (rp->p_size+7)/8, rp->p_addr);
        rp->p_addr = a;
        rp->p_flag =| SLOAD;
        rp->p_time = 0;
        goto loop;

swaper:
        panic("swap error");
}
```
#### sleep

Give up the processor till a wakeup occurs on chan, at which time the process enters the scheduling queue at priority pri. The most important effect of pri is that when pri<0 a signal cannot disturb the sleep; if pri>=0 signals will be processed. Callers of this routine must be prepared for premature return, and check that the reason for sleeping has gone away.

```c
sleep(chan, pri)
{
        register *rp, s;

        s = PS->integ;
        rp = u.u_procp;
        if(pri >= 0) {
                if(issig())
                        goto psig;
                spl6();
                rp->p_wchan = chan;
                rp->p_stat = SWAIT;
                rp->p_pri = pri;
                spl0();
                if(runin != 0) {
                        runin = 0;
                        wakeup(&runin);
                }
                swtch();
                if(issig())
                        goto psig;
        } else {
                spl6();
                rp->p_wchan = chan;
                rp->p_stat = SSLEEP;
                rp->p_pri = pri;
                spl0();
                swtch();
        }
        PS->integ = s;
        return;

        /* If priority was low (>=0) and
         * there has been a signal,
         * execute non-local goto to
         * the qsav location.
         * (see trap1/trap.c) */
psig:
        aretu(u.u_qsav);
}

```

```c
/* Wake up all processes sleeping on chan. */
wakeup(chan)
{
        register struct proc *p;
        register c, i;

        c = chan;
        p = &proc[0];
        i = NPROC;
        do {
                if(p->p_wchan == c) {
                        setrun(p);
                }
                p++;
        } while(--i);
}

/* Set the process running; arrange for it to be swapped in if necessary. */
setrun(p)
{
        register struct proc *rp;

        rp = p;
        rp->p_wchan = 0;
        rp->p_stat = SRUN;
        if(rp->p_pri < curpri)
                runrun++;
        if(runout != 0 && (rp->p_flag&SLOAD) == 0) {
                runout = 0;
                wakeup(&runout);
        }
}

/* Set user priority.
 * The rescheduling flag (runrun)
 * is set if the priority is higher
 * than the currently running process. */
setpri(up)
{
        register *pp, p;

        pp = up;
        p = (pp->p_cpu & 0377)/16;
        p =+ PUSER + pp->p_nice;
        if(p > 127)
                p = 127;
        if(p > curpri)
                runrun++;
        pp->p_pri = p;
}

```

#### swtch
This routine is called to reschedule the CPU. if the calling process is not in RUN state, arrangements for it to restart must have been made elsewhere, usually by calling via sleep.

```c
swtch()
{
        static struct proc *p;
        register i, n;
        register struct proc *rp;

        if(p == NULL)
                p = &proc[0];
        /* Remember stack of caller */
        savu(u.u_rsav);
        /* Switch to scheduler's stack */
        retu(proc[0].p_addr);

loop:
        runrun = 0;
        rp = p;
        p = NULL;
        n = 128;
        /* Search for highest-priority runnable process */
        i = NPROC;
        do {
                rp++;
                if(rp >= &proc[NPROC])
                        rp = &proc[0];
                if(rp->p_stat==SRUN && (rp->p_flag&SLOAD)!=0) {
                        if(rp->p_pri < n) {
                                p = rp;
                                n = rp->p_pri;
                        }
                }
        } while(--i);
        /* If no process is runnable, idle. */
        if(p == NULL) {
                p = rp;
                idle();
                goto loop;
        }
        rp = p;
        curpri = n;
        /* Switch to stack of the new process and set up
         * his segmentation registers. */
        retu(rp->p_addr);
        sureg();
        /* If the new process paused because it was
         * swapped out, set the stack level to the last call
         * to savu(u_ssav).  This means that the return
         * which is executed immediately after the call to aretu
         * actually returns from the last routine which did
         * the savu.
         *
         * You are not expected to understand this. */
        if(rp->p_flag&SSWAP) {
                rp->p_flag =& ~SSWAP;
                aretu(u.u_ssav);
        }
        /* The value returned here has many subtle implications.
         * See the newproc comments. */
        return(1);
}

```

#### Expand
Change the size of the data+stack regions of the process. If the size is shrinking, it's easy-- just release the extra core. If it's growing, and there is core, just allocate it and copy the image, taking care to reset registers to account for the fact that the system's stack has moved.

If there is no core, arrange for the process to be swapped out after adjusting the size requirement-- when it comes in, enough core will be allocated. Because of the ssave and SSWAP flags, control will resume after the swap in swtch, which executes the return from this stack level.

After the expansion, the caller will take care of copying the user's stack towards or away from the data area.

```c
expand(newsize)
{
        int i, n;
        register *p, a1, a2;

        p = u.u_procp;
        n = p->p_size;
        p->p_size = newsize;
        a1 = p->p_addr;
        if(n >= newsize) {
                mfree(coremap, n-newsize, a1+newsize);
                return;
        }
        savu(u.u_rsav);
        a2 = malloc(coremap, newsize);
        if(a2 == NULL) {
                savu(u.u_ssav);
                xswap(p, 1, n);
                p->p_flag =| SSWAP;
                swtch();
                /* no return */
        }
        p->p_addr = a2;
        for(i=0; i<n; i++)
                copyseg(a1+i, a2++);
        mfree(coremap, n, a1);
        retu(p->p_addr);
        sureg();
}
```

### prd.c

```c
#include "../param.h"
#include "../seg.h"
#include "../buf.h"
#include "../conf.h"

/*
 * Address and structure of the
 * KL-11 console device registers.
 */
struct
{
        int     rsr;
        int     rbr;
        int     xsr;
        int     xbr;
};

/*
 * In case console is off,
 * panicstr contains argument to last
 * call to panic.
 */

char    *panicstr;

/*
 * Scaled down version of C Library printf.
 * Only %s %l %d (==%l) %o are recognized.
 * Used to print diagnostic information
 * directly on console tty.
 * Since it is not interrupt driven,
 * all system activities are pretty much
 * suspended.
 * Printf should not be used for chit-chat.
 */
printf(fmt,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc)
char fmt[];
{
        register char *s;
        register *adx, c;

        adx = &x1;
loop:
        while((c = *fmt++) != '%') {
                if(c == '\0')
                        return;
                putchar(c);
        }
        c = *fmt++;
        if(c == 'd' || c == 'l' || c == 'o')
                printn(*adx, c=='o'? 8: 10);
        if(c == 's') {
                s = *adx;
                while(c = *s++)
                        putchar(c);
        }
        adx++;
        goto loop;
}

/*
 * Print an unsigned integer in base b.
 */
printn(n, b)
{
        register a;

        if(a = ldiv(n, b))
                printn(a, b);
        putchar(lrem(n, b) + '0');
}

```

Print a character on console. Attempts to save and restore device status. If the switches are 0, all printing is inhibited.

```c
putchar(c)
{
        register rc, s;

        rc = c;
        if(SW->integ == 0)
                return;
        while((KL->xsr&0200) == 0)
                ;
        if(rc == 0)
                return;
        s = KL->xsr;
        KL->xsr = 0;
        KL->xbr = rc;
        if(rc == '\n') {
                putchar('\r');
                putchar(0177);
                putchar(0177);
        }
        putchar(0);
        KL->xsr = s;
}

```

Panic is called on unresolvable fatal errors. It syncs, prints "panic: mesg" and then loops.

```

panic(s)
char *s;
{
        panicstr = s;
        update();
        printf("panic: %s\n", s);
        for(;;)
                idle();
}

```

prdev prints a warning message of the form "mesg on dev x/y". x and y are the major and minor parts of the device argument.

```c

prdev(str, dev)
{

        printf("%s on dev %l/%l\n", str, dev.d_major, dev.d_minor);
}

/*
 * deverr prints a diagnostic from
 * a device driver.
 * It prints the device, block number,
 * and an octal word (usually some error
 * status register) passed as argument.
 */
deverror(bp, o1, o2)
int *bp;
{
        register *rbp;

        rbp = bp;
        prdev("err", rbp->b_dev);
        printf("bn%l er%o %o\n", rbp->b_blkno, o1, o2);
}
```

### malloc.c
This file contains the `malloc` and `mfree` procedures. The first _allocates_ memory and the second _releases_ it. 

This can either be actual RAM (in units of 32 words/64 bytes) or the disk swap (256 words/512 bytes). The `int coremap[100]` and `int swapmap[100]` variables declared in the headers are the list of available 'areas'. Either `coremap` or `swapmap` is passed to `malloc` or `mfree`.

When it's passed to one of these functions, it's interpreted as a 'map' structure of two unsigned integers, one representing the size of the available block, and one the address of that block. The map is defined as:

```c
struct map {
    char* m_size;
    char* m_addr;
};
```
You can think of the map as a table of blocks, with columns for size and address of the blocks.

```
el | size | address 
---|------|--------
...| ...  |   ...
 4 |  10  |   100
 5 |  50  |   500
 6 |   0  |   600 <- note size==0 acts as 'sentinal'
```

#### malloc
When asked for a block of memory of a certain size, `malloc` finds the address of a piece of memory that fits the bill, and returns that address.

The function looks through the table for a 'block' of adequate size. That is, one where the size which the caller is requesting is smaller than or equal to the size of the block available [^2]. It either finds one, in which case it returns a pointer to that address, or it reaches the end of the maps without finding a block, and returns zero.

[^2]: For this reason, the allocation algorithm is known as 'first fit'.

When a suitable block has been found, the address of the block is reduced by the requested size, and the size of the block is _reduced_ by the requested size. So if there was a request for 100 bytes, and the block was size 200 at address 10000, the _new_ block would be size 100 at address 10100.

There is an important last step: If, by allocating the new memory, the size of the block is now zero, then everything gets 'shifted up'. This ensures that there are no 'hanging' empty blocks in the middle of the table, which would cause the algorithm to fail to allocate prematurely. An illustration of this is below the code.

Here is the source code for `malloc`. It has been slightly changed to make the C more modern, and the names more descriptive.

```c
int malloc(map* mem_table, int size) {
    int return_pointer;
    struct map* block;

    for (block = mem_table; block->m_size > 0; block++) { 
        if (block->m_size >= size) {
            return_pointer = block->m_addr;
            block->m_addr =+ size;
            block->m_size =- size;
            if (block->m_size == 0)
                do {
                    block++;
                    (block-1)->m_addr = block->m_addr;
                    (block-1)->m_size = block->m_size;
                } while ((block-1)->m_size > 0);

            return(return_pointer);
        }
    }
    return(0);
}
```
The illustration of the 'table shifting':
```
el | size | adk 
---|------|----
...| ...  | ...
 4 |  10  | 100 <- before request for 10
 5 |  50  | 500
 6 |   0  | 600 <- note size==0 acts as 'sentinal'

el | size | add 
---|------|----
...| ...  | ...
 4 |   0  | 110 <- after request for 10, size is now 0
 5 |  50  | 500
 6 |   0  | 600 

el | size | add 
---|------|----
...| ...  | ...
 4 |   0  | 110
 5 |  50  | 500 <- block now points here (block++)
 6 |   0  | 600 


el | size | add 
---|------|----
...| ...  | ...
 4 |  50  | 500 <- (block-1)->m_addr = block->m_addr, (block-1)->m_size = block->m_size
 5 |  50  | 500 <- block still points here
 6 |   0  | 600 

(block-1)->m_size != 0, so we continue

el | size | add 
---|------|----
...| ...  | ...
 4 |  50  | 500
 5 |  50  | 500
 6 |   0  | 600 <- block++ now points here

el | size | add 
---|------|----
...| ...  | ...
 4 |  50  | 500
 5 |   0  | 600 <- (block-1)->m_addr = block->m_addr, (block-1)->m_size = block->m_size
 6 |   0  | 600 <- block still points here

(block-1)->m_size == 0, so we are done
```

#### mfree
When freeing memory, the table, the size, and the address is passed in. The function then creates a new entry in the table with those values. However, doing this is a recipe for many tiny blocks of memory that can't actually be used. We need a mechanism for merging blocks if they are contiguous.

Consider the case `mfree(table, 50, 1000)` in the context of the table

```
el | size | add 
---|------|----
...| ...  | ...
 4 |  50  |  500
 5 |  50  |  950
 6 |  50  | 1050

el | size | add 
---|------|----
...| ...  | ...
 4 |  50  |  500
 5 |  50  |  950
 x |  50  | 1000 <- We want to insert here
 6 |  50  | 1050
```

Here, we have 3 contiguous blocks: 5, x and 6. We want to merge these blocks into one, to end up with

```
el | size | add 
---|------|----
...| ...  | ...
 4 |  50  |  500
 5 | 150  |  950
...| ...  | ...
```
The algorithm is for freeing a block X is:
1. Find the first block in the table where the address is greater than the start address of X.
2. Look at the block _before_ this. Call this block A. If the block X is contiguous with A (`A.addr + A.size == X.addr`), then instead of inserting a new block for X, we want to _extend_ block A.
3. Next we look at the block we got in step 1. Call this block B. If X is contiguous with A and B, we need to _merge_ our newly extended A with B. This is the same 'shift up' operation we saw in `malloc`
4. If X is not contiguous with A, but is contiguous with B, just extend B backwards
5. Is X is not contiguous with A or B, we need to 'insert' a row into the table.

```c
void mfree(map* mem_table, int size, int addr_to_free) {
    struct map* block;
    int temp_address;

    // Step 1
    for (block = mem_table; block->m_addr<=addr_to_free && block->m_size!=0; block++);

    // Step 2
    if (block > mem_table && (block-1)->m_addr+(block-1)->m_size == addr_to_free) {
        (block-1)->m_size =+ size;
        // Step 3
        if (addr_to_free+size == block->m_addr) {
           (block-1)->m_size =+ block->m_size;
           while (block->m_size > 0) {
              block++;
              (block-1)->m_addr = block->m_addr;
              (block-1)->m_size = block->m_size;
           }
        }
    } else {
        // Step 4
        if (addr_to_free+size == block->m_addr && block->m_size > 0) {
            block->m_addr =- size;
            block->m_size =+ size;
        } else if (size > 0) {
            // Step 5
            do {
                temp_address = block->m_addr;
                block->m_addr = addr_to_free;
                addr_to_free = temp_address;
                temp_address = block->m_size;
                block->m_size = size;
                block++;
            } while (size = temp_address);
        }
    }
}
```
