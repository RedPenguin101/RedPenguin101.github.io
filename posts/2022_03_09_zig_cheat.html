<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2022_03_09_zig_cheat</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../css/style.css" />
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#zig-cheat-sheet">Zig Cheat Sheet</a><ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#split-vs.-tokenize">Split vs. Tokenize</a></li>
<li><a href="#io">IO</a><ul>
<li><a href="#readers">Readers</a></li>
<li><a href="#writers">Writers</a></li>
</ul></li>
<li><a href="#string-formatting">String formatting</a></li>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#dynamic-memory-and-allocators">Dynamic memory and allocators</a></li>
<li><a href="#enums">enums</a></li>
<li><a href="#tests">tests</a></li>
<li><a href="#hashmaps">Hashmaps</a></li>
<li><a href="#build">Build</a></li>
<li><a href="#polymorphism">Polymorphism</a><ul>
<li><a href="#comptime">Comptime</a></li>
<li><a href="#runtime">Runtime</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="zig-cheat-sheet">Zig Cheat Sheet</h1>
<h2 id="syntax">Syntax</h2>
<p><code>.?</code> is shorthand for <code>orelse unreachable</code>. Used when a call returns an option type, and you want an <code>null</code> to throw.</p>
<pre class="zig"><code>const dir = line_it.next().?;</code></pre>
<p><code>try x</code> is a shorthand for <code>x catch |err| return err</code></p>
<p>Struct with methods.</p>
<pre class="zig"><code>const Pair = struct {
    lhs: u8,
    rhs: u8,

    pub fn equals(lhs: Pair, rhs: Pair) bool {
        return lhs.lhs == rhs.lhs and lhs.rhs == rhs.rhs;
    }

    pub fn hash(self: Pair) u32 {
        return @intCast(u32, self.lhs) + @intCast(u32, self.rhs) * 100;
    }
};

const pair = Pair { .lhs = pair_string[0], .rhs = pair_string[1], };</code></pre>
<p>Anonymous structs:</p>
<pre class="zig"><code>fn getCoords(index: usize) struct { x: usize, y: usize } {
    return .{
        .x = index % LINE_LENGTH,
        .y = index / LINE_LENGTH,
    };
}</code></pre>
<p>Switch statement</p>
<pre class="zig"><code>switch (dir[0]) {
    &#39;f&#39; =&gt; x += num,
    &#39;u&#39; =&gt; y -= num,
    &#39;d&#39; =&gt; y += num,
    else =&gt; @panic(&quot;couldn&#39;t match direction&quot;),
}</code></pre>
<h2 id="loops">Loops</h2>
<p>While with continue expression:</p>
<pre class="zig"><code>while (i &lt;= 10) : (i += 1) {
    sum += i;
}</code></pre>
<p>For with index capture</p>
<pre class="zig"><code>for (string) |character, index| {
}</code></pre>
<p>For with pointer</p>
<pre class="zig"><code>for (grid) |*value, i| {
    value.* += 1; // will modify the elements of grid
    if (value.* &gt; 9) {
        value.* = 100;
        try flash_indices.append(i);
    }
}</code></pre>
<h2 id="macros">Macros</h2>
<pre class="zig"><code>@minimum(a, b);
@maximum(a, b);
@intCast(u4, char);
@panic(&quot;message&quot;);
@as(u32, 1234);
@sizeOf(usize);
@embedFile(&quot;./resouces/day05input.txt&quot;);</code></pre>
<h2 id="split-vs.-tokenize">Split vs. Tokenize</h2>
<h2 id="io">IO</h2>
<pre class="zig"><code>var file = try std.fs.cwd().openFile(&quot;./resources/day05input.txt&quot;, .{});
defer file.close();

const stdin = std.io.getStdIn();
const stdout = std.io.getStdOut();</code></pre>
<h3 id="readers">Readers</h3>
<p>Reading from stdin</p>
<pre class="zig"><code>while (try stdin.reader().readUntilDelimiterOrEof(&amp;num_buff, &#39;\n&#39;)) |num_str| {}
var x = try stdin.reader().readAll(&amp;board_str);

const x1_string = try file.reader().readUntilDelimiter(buffer[0..], &#39;,&#39;);
const char = try file.reader().readByte();
file.reader().skipUntilDelimiterOrEof(&#39;\n&#39;);</code></pre>
<h3 id="writers">Writers</h3>
<p>Write to stdout</p>
<pre class="zig"><code>try stdout.writer().print(&quot;Day 1 Part 1: {}\n&quot;, .{count_p1});</code></pre>
<h2 id="string-formatting">String formatting</h2>
<pre class="zig"><code>std.debug.print(&quot;vent counts: {}\n&quot;, .{vent_counts.len});</code></pre>
<h2 id="arrays">Arrays</h2>
<p>Initialize an array of zeros</p>
<pre class="zig"><code>var vent_counts = [_]i32{0} ** (1000 * 500);</code></pre>
<p>Slice array with <code>array[0..3]</code>. The slice type is a pointer and a size. <code>array[0..]</code> is a slice to the end.</p>
<h2 id="parsing">Parsing</h2>
<pre class="zig"><code>try std.fmt.parseInt(usize, num_str, 2);</code></pre>
<h2 id="numbers">Numbers</h2>
<pre class="zig"><code>var least_common: u64 = std.math.maxInt(u64);</code></pre>
<h2 id="pointers">Pointers</h2>
<ul>
<li>Type syntax <code>*T</code> for pointee type <code>T</code>.</li>
<li>Compute pointer with <code>&amp;variable</code> (“address of” operator)</li>
<li>Deference with <code>variable.*</code></li>
<li>No <code>NULL</code> (0) pointer from C.</li>
</ul>
<pre class="zig"><code>fn increment(num: *u8) void {
    num.* += 1;
}

fn main() !void {
    var x: u8 = 1;
    increment(&amp;x);
}</code></pre>
<ul>
<li>const pointer (<code>*const T</code>) can’t be used to modify referenced data.</li>
<li>A computed pointer to a const will yield a const pointer.</li>
</ul>
<p>From <a href="https://nmichaels.org/zig/pointers.html">here</a></p>
<ul>
<li><code>*T</code> is a one-item pointer</li>
<li><code>[*]T</code> is an unknown-length pointer. Don’t use them!</li>
</ul>
<pre class="zig"><code>var orders: [18]u8 = [_]u8{
        &#39;T&#39;, &#39;a&#39;, &#39;k&#39;, &#39;e&#39;, &#39; &#39;, &#39;o&#39;, &#39;f&#39;, &#39;f&#39;, &#39; &#39;, &#39;e&#39;, &#39;v&#39;, &#39;e&#39;, &#39;r&#39;, &#39;y&#39;, &#39; &#39;, &#39;z&#39;, &#39;i&#39;, &#39;g&#39;,
};
var order_ptr: [*]u8 = &amp;orders;
order_ptr[3];
order_ptr[100]; // legal and dangerous!</code></pre>
<ul>
<li>Fixed by <em>slice</em> - struct of <code>[*]T</code> and <code>len: usize</code></li>
<li>Slice type is <code>[]T</code> (or <code>[]const T</code></li>
<li>Create with <code>var slice: []const u8 = orders[0..]</code> or <code>var slice: []const u8 = &amp;orders</code>. You can get more specific with the ranges.</li>
</ul>
<pre class="zig"><code>// var slice with const vals
var slice: []const u8 = orders[0..];
slice = orders[5..8]; // Legal
slice[0] = &#39;X&#39;; // error: cannot assign to constant
// const slice with var vals
const slice2: []u8 = orders[0..];
slice2[0] = &#39;X&#39;; // Legal
slice2 = orders[5..8]; // error: cannot assign to constant</code></pre>
<ul>
<li>Function params are always <code>const</code></li>
</ul>
<h2 id="dynamic-memory-and-allocators">Dynamic memory and allocators</h2>
<pre class="zig"><code>test &quot;GPA&quot; {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    defer {
        const leaked = gpa.deinit();
        if (leaked) expect(false) catch @panic(&quot;TEST FAIL&quot;); //fail test; can&#39;t try in defer as defer is executed after we return
    }
    
    const bytes = try allocator.alloc(u8, 100);
    defer allocator.free(bytes);
}</code></pre>
<pre class="zig"><code>test &quot;allocation&quot; {
    const allocator = std.heap.page_allocator;

    const memory = try allocator.alloc(u8, 100);
    defer allocator.free(memory);
    // defer and free pattern

    try expect(@TypeOf(memory) == []u8);
    try expect(memory.len == 100);
}</code></pre>
<p>Fixed buffer allocator is stack allocator.</p>
<pre class="zig"><code>test &quot;fixed buffer allocator&quot; {
    var buffer: [1000]u8 = undefined;
    var fba = std.heap.FixedBufferAllocator.init(&amp;buffer);
    const allocator = fba.allocator();

    const memory = try allocator.alloc(u8, 100);
    defer allocator.free(memory);

    try expect(memory.len == 100);
    try expect(@TypeOf(memory) == []u8);
}</code></pre>
<h2 id="enums">enums</h2>
<pre class="zig"><code>const CaveType = enum {
    Start,
    End,
    Small,
    Large,
};

fn getCaveType(cave: []const u8) CaveType {
    if (equals(cave, &quot;start&quot;)) return .Start;
    if (equals(cave, &quot;end&quot;)) return .End;
    if (cave[0] &gt;= &#39;A&#39; and cave[0] &lt;= &#39;Z&#39;) return .Large;
    if (cave[0] &gt;= &#39;a&#39; and cave[0] &lt;= &#39;z&#39;) return .Small;
    unreachable;
}</code></pre>
<h2 id="tests">tests</h2>
<pre class="zig"><code>test &quot;test-input-1&quot; {
    const result = try execute(test_input_1);
    const expected: u32 = 36;
    try std.testing.expectEqual(expected, result);
}</code></pre>
<h2 id="hashmaps">Hashmaps</h2>
<pre class="zig"><code>var new_pairs = std.AutoHashMap(u32, u64).init(alloc.allocator());
defer new_pairs.deinit();</code></pre>
<p>methods</p>
<ul>
<li><code>put</code></li>
<li><code>getOrPut</code></li>
<li><code>clearRetainingCapacity</code></li>
</ul>
<h2 id="build">Build</h2>
<p><code>zig build-exe file.zig</code></p>
<h2 id="polymorphism">Polymorphism</h2>
<h3 id="comptime">Comptime</h3>
<pre class="zig"><code>pub fn swap(comptime T: type, a: *T, b: *T) void {
    const tmp = a.*;
    a.* = b.*;
    b.* = tmp;
}

pub fn reverse(comptime T: type, items: []T) void {
    var i: usize = 0;
    const end = items.len / 2;
    while (i &lt; end) : (i += 1) {
        swap(T, &amp;items[i], &amp;items[items.len - i - 1]);
    }
}</code></pre>
<h3 id="runtime">Runtime</h3>
</body>
</html>
