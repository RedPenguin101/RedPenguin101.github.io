<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2021_12_16_dont_start_micro</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="dont-start-with-microservices">Don’t start with Microservices</h1>
<p>Notes on a <a href="https://arnoldgalovics.com/microservices-in-production/">blog post</a> by Arnold Galovics</p>
<p>Microservices have several purported benefits.</p>
<ul>
<li>Fault Isolation</li>
<li>Avoid locking in to technology</li>
<li>Easier to understand</li>
<li>Faster to deploy</li>
<li>Scalable</li>
</ul>
<p>But <em>none</em> of them come for free. You have to design for them, and in practice they are hard to accomplish.</p>
<p>The first diffultly is <strong>infra</strong>. Monoliths just need less stuff than microservices. More accurately they tend to handle more stuff in the frameworks they run on. Which means more cost. Also, more moving pieces means more failures, and more complex failures.</p>
<p><strong>JL:</strong> Agreed. Monoliths handle a lot of that stuff for you. They are obviously very tightly coupled, but usually very reliable as a result of that.</p>
<p>The <strong>faster deployments</strong> benefit should come with an asterisk. The goal of the microservice is that it’s <em>independently deployable</em>. i.e. you can deploy a change without it impacting anything else. This is either <em>very hard</em> to do, or for a subset of work, maybe just impossible. If you have a chain of microservices that talk to eachother, and you want to change one in the middle, it’s unlikely you will <em>want</em> to deploy that one in isolation, because the changes from that will likely <em>by design</em> flow down the service chain to impact an end result (otherwise why do the change?). This isn’t the case with pure refactorings or bug fixes, obviously, but for actual feature addition it’s practically definitional that you won’t want to deploy independently.</p>
<p><strong>JL:</strong> counterpoint to this: As long as you’re not making breaking changes to the API, you should be able to deploy separately. Like you make a non-breaking change to Service A, which is used by B. Maybe you add a new route <code>thing2</code> in addition to <code>thing</code>. A can be deployed just fine, since B will just use <code>thing</code>, which is unchanged. Then you can move on to deploying a new version of B, which now calls <code>thing2</code>. You are once again independently deployable.</p>
<p>Another difficulty is the impact an MS architecture has on the organization. The reality is that a PO (who doesn’t care about the architecture) will ask for a feature that will require touching many services, but the changes to each service will not be meaningful in isolation, so you can’t develop iteratively. The change will take <em>longer</em> than in a corresponding monolith.</p>
<p><strong>JL:</strong> reminds me of that <a href="https://www.youtube.com/watch?v=y8OnoxKotPQ">Krazam</a> video. All of these points are based on Microservices not being actually isolated in practice. The title of the article might be <strong><em>Don’t start with microservices if you can’t isolate them properly</em></strong>. Maybe a corollary would be <strong><em>you can’t isolate microservices properly in a new build, because you don’t understand the correct way to divide the parts yet</em></strong>. The author doesn’t explicitly say it I think, but it seems to me to be implied.</p>
<p>Addressing the <strong>fault isolation</strong> point, the authors point is that it take a lot of difficult design work to get that right. It’s never free, you pay for it, and like anything you have to weigh the costs and benefits.</p>
<h2 id="my-thoughts">My thoughts</h2>
<p>The title says <em>don’t <strong>start</strong> with microservices</em>, but I don’t think he ever comes out and says what to me is the main thrust of the article. It even comes in a pleasingly syllogistic form:</p>
<ol type="1">
<li>The benefits of microservices all come from decoupled services</li>
<li>In a new system, you don’t know ahead of time where the appropriate “dividing lines” between services are. So any services you build for a new system will not be optimally isolated</li>
<li>So you shouldn’t use microservices on new build.</li>
</ol>
<p>The article mainly talks about the problems that arise from inadequately decoupled services. His other main point is that adequate decoupling doesn’t come for free: you have to work on it a lot.</p>
<p>I’m not clear on whether the author recommends <em>never</em> using microservices, or is cautioning about the costs, or is saying that you should start more monolithically and <em>evolve</em> towards a microservice architecture.</p>
<p>One thing that kept popping up in my head is that the way this article, and most of them, talk about microservices is like the ‘swarm of bees’ model. Like you have 100 services all buzzing around and interacting. And you have to think about all the bees in the swarm.</p>
<p>But that’s alien to how we do software design anywhere else. A big part of design is in creating <em>layers</em> and <em>hiding detail</em>. Combining lower level things into a higher level thing, enabling you to think in that higher level thing without worrying about the detail. But that seems to be pretty absent from the microservice discourse. You have to think about all the bees.</p>
<p>It seems to me that creating that higher level view would be beneficial, since you have to worry less about whether the individual services within that view are totally isolated, as long the higher level things <em>themselves</em> are isolated from eachother.</p>
</body>
</html>
